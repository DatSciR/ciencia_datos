---
title: | 
  | Ciencia de datos en R ![](images/Escuela de Doctorado_trilingue_positivo.png){width=80%,fig-align="right"}
subtitle: "Programaci贸n: aprendiendo a programar con funciones"
author: Julen Astigarraga and Ver贸nica Cruz-Alonso
date: today
date-format: "DD/MM/YYYY"
toc: true
toc-depth: 4
toc-title: "ndice"
format:
  html:
    link-external-newwindow: true
    # css: styles.css
  gfm: default
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
---

## Objetivos del d铆a 3

Los **objetivos** del d铆a de hoy son:

-   aprender a escribir funciones

-   aplicar funciones en programaci贸n iterativa mediante el paquete {purrr} de {tidyverse}

Dentro del modelo de ciencia de datos de Hadley Wickham, Mine etinkaya-Rundel y Garrett Grolemund (@fig-datascience), el d铆a de hoy se centra en el marco que envuelve todo el proceso, es decir, la programaci贸n.

![Modelo de ciencia de datos de Hadley Wickham, Mine etinkaya-Rundel y Garrett Grolemund. Traducido de https://r4ds.hadley.nz/intro#fig-ds-diagram](images/datascience.png){#fig-datascience}

## Introducci贸n a la programaci贸n funcional

La creciente disponibilidad de datos y de versatilidad de los programas de an谩lisis han provocado el incremento en la cantidad y complejidad de los an谩lisis que realizamos. Esto hace cada vez m谩s necesaria la eficiencia en el proceso de gesti贸n y an谩lisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programaci贸n basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el c贸digo.

Como las funciones en R son objetos, es posible llamarlas a trav茅s de otras funciones e iterar este proceso, lo que constituye la base de la programaci贸n funcional y convierte a R en una herramienta muy poderosa. Las iteraciones sirven para realizar la misma acci贸n a m煤ltiples entradas.

```{r ejemplo_importancia_PF}
#| warning: false

# install.packages("palmerpenguins")
library(palmerpenguins)
library(tidyverse)

df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

df_rescaled1 <- df |> 
  mutate(bill_length_mm = (bill_length_mm - min(bill_length_mm, na.rm = TRUE)) / (max(bill_length_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)),
    bill_depth_mm = (bill_depth_mm - min(bill_depth_mm, na.rm = TRUE)) / (max(bill_depth_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)),
    flipper_length_mm = (flipper_length_mm - min(flipper_length_mm, na.rm = TRUE)) / (max(flipper_length_mm, na.rm = TRUE) - min(flipper_length_mm, na.rm = TRUE)),
    body_mass_g = (body_mass_g - min(body_mass_g, na.rm = TRUE)) / (max(body_mass_g, na.rm = TRUE) - min(body_mass_g, na.rm = TRUE)))
    
View(df_rescaled1)

#
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1]) 
} 

df_rescaled2 <- df |> 
  mutate(bill_length_mm = rescale01(bill_length_mm),
         bill_depth_mm = rescale01(bill_depth_mm),
         flipper_length_mm = rescale01(flipper_length_mm), 
         body_mass_g = rescale01(body_mass_g))  

View(df_rescaled2)

#
df_rescaled3 <- lapply(df, rescale01)

View(df_rescaled3)

```

Las principales **ventajas de la programaci贸n funcional** (uso de funciones e iteraciones) son:

-   Facilidad para ver la intenci贸n del c贸digo y, por tanto, mejorar la **comprensi贸n** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El c贸digo queda m谩s ordenado.
-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.
-   **Disminuye la probabilidad de error**.

### 驴Cu谩ndo hay que usar una funci贸n?

Se recomienda seguir el principio "do not repeat yourself" ([DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.)): cada unidad de conocimiento o informaci贸n debe tener una representaci贸n 煤nica, inequ铆voca y autoritativa en un sistema.

Escribir una funci贸n ya merece la pena cuando has copiado y pegado m谩s de dos veces lo mismo (don't be WET! - Write Everything Twice). Cuantas m谩s veces est茅 repetido un c贸digo, en m谩s sitios necesitar谩s actualizarlo si hay algun cambio y m谩s aumenta la probabilidad de error.

## Teor铆a sobre funciones en R

Seg煤n el tipo de output generado hay dos tipos de funciones:

-   Las **funciones de transformaci贸n** transforman el objeto que entra en la funci贸n (primer argumento) y devuelven otro objeto o el anterior modificado. Los funcionales son tipos especiales de funciones de transformaci贸n.

    ![](images/function.png)

-   Las **funciones secundarias** (*side-effect functions*) tienen efectos colaterales y ejecutan una acci贸n, como guardar un archivo o dibujar un plot. Algunos ejemplos de funciones secundarias que se usan comunmente son: `library()`, `setwd()`, `plot()`, `write_delim()`... Estas funciones retornan *de forma invisible* el primer argumento, que no se guarda, pero puede ser usado en un *pipeline*.

En general, sint谩cticamente, las funciones tienen tres componentes:

-   Funci贸n `function()` (primitiva)
-   Argumentos: lista de entradas.
-   Cuerpo: trozo de c贸digo que sigue a `function()`, tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {
  paste(x, y, sep = "_")
}  

nombre1_v2 <- function(x, y) paste(x, y, sep = "_")  

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")

nombre1_v1("Vero", "Cruz") 
nombre1_v2("Vero", "Cruz") 
nombre1_v3("Vero", "Cruz") 

```

 Si la funci贸n tiene m谩s de dos lineas es mejor usar llaves siempre para que quede bien delimitada. La llave de apertura nunca debe ir sola pero s铆 la de cierre (excepto con *else*). Las sangr铆as tambi茅n ayudan mucho a entender la jerarqu铆a del c贸digo dentro de las funciones.

En general las funciones tienen un nombre que se ejecuta cuando se necesita como hemos visto hasta ahora, pero esto no es obligatorio. Algunos paquetes como {purrr} o las funciones de la familia `apply` permiten el uso de **funciones an贸nimas** para iterar.

```{r funciones_anonimas}

map(penguins, function(x) length(unique(x)))

penguins |> 
  map(function(x) length(unique(x)))

```

 Mejor reservar el uso de funciones an贸nimas para funciones cortas y simples. Si la funci贸n es larga, ocupa varias l铆neas o tenemos que usarla con frecuencia mejor darle un nombre.

## C贸mo escribir funciones {#sec-writefun}

#### Ejercicio

Genera tu primera funci贸n que divida un valor siempre entre 100.

Atajo para escribir funciones: escribir la palabra fun + tabulador

Imaginad que para un set de datos quisieramos hacer un gr谩fico de distribuci贸n de cada variable num茅rica, en funci贸n de otra variable categ贸rica que nos interese especialmente, para ver c贸mo se distribuye.

```{r codigo_repetido_avanzado}
#| warning: false

penguins_num <- penguins |> 
  select(species, sex, where(is.numeric))

# nos interesan las diferencias entre especie y sexo

ggplot(penguins_num, aes(x = species, y = bill_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = bill_depth_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = flipper_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

# etc
```

Hemos copiado un c贸digo m谩s de dos veces para realizar una misma acci贸n (es decir, un gr谩fico para ver como se distribuye una variable en funci贸n de otras dos que se mantienen constantes) as铆 que hay que considerar la posibilidad de que estemos necesitando una funci贸n. A continuaci贸n vamos a seguir unos sencillos pasos para transformar cualquier c贸digo repetido en funci贸n.

1.  Analizar el c贸digo: 驴cu谩les son las partes replicadas? 驴cuantas entradas tenemos? 驴cu谩les var铆an y cu谩les no?

2.  Simplificar y reanalizar duplicaciones

```{r funcion_simplificar}
#| warning: false

var <- penguins_num$bill_length_mm

ggplot(penguins_num, aes(x = species, y = var, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()
 
```

```{r funcion_simplificar_2}
#| warning: false
#| error: true

var <- body_mass_g
var <- "body_mass_g"

ggplot(penguins_num, aes(x = species, y = var, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light() +
  ylab(var) # grafico erroneo

ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light() +
  ylab(var) # grafico correcto


```

 La funci贸n `ggplot` necesita argumentos (data-variable) que est茅n dentro del `data.frame` que va a representar. Para poder generalizar la funci贸n hemos guardado el nombre de la variable en un objeto (tipo `character`), pero `ggplot` no acepta `characters`. Por ello necesitamos utilizar una funci贸n intermedia que s铆 los acepte. Para resolver problemas comunes de programaci贸n funcional derivados de la *non-standard evaluation* de *tidyverse* [mira este enlace](https://dplyr.tidyverse.org/articles/programming.html#introduction).

![*tidyverse* permite usar data-variables (juguetes dentro de la caja el data.frame) como si fueran env-variables (juguetes sobre las alfombras). Cuando Monchi usa las *tidygafas* puede acceder tambi茅n f谩cilmente a los juguetes de la caja. Las *tidygafas* hacen que Monchi *eval煤e* la funci贸n en un entorno diferente al que ser铆a habitual. Ilustraci贸n de Cristina Grajera](images/data_masking.png){alt="tidyverse permite usar data-variables (juguetes dentro de la caja el data.frame) como si fueran env-variables (juguetes sobre las alfombras). Cuando Monchi usa las tidygafas puede acceder tambi茅n f谩cilmente a los juguetes de la caja. Las tidygafas hacen que Monchi eval煤e la funci贸n en un entorno diferente al que ser铆a habitual. Ilustraci贸n de Cristina Grajera"}

3.  Elegir un nombre para la funci贸n (). Idealmente tiene que ser corto y evocar lo que la funci贸n hace. En general, debe ser un verbo (p. ej. imputar_valores) mientras que los argumentos son sustantivos (p. ej. data, variable, etc.). Usar un sustantivo para una funci贸n est谩 permitido si la funci贸n calcula algo muy conocido (p. ej. `mean()`) o si sirve para acceder a partes de un objeto (p. ej. `residuals()`). Tambi茅n se recomienda evitar verbos muy gen茅ricos (p. ej. calcular) y si el nombre tiene varias palabras separarlas con gui贸n bajo o may煤sculas, pero ser consistente. Si programas varias funciones que hacen cosas parecidas se recomienda usar el mismo prefijo para todas (p. ej. "str\_" en el paquete {stringr}).

4.  Enumerar los argumentos dentro de `function()` y poner el c贸digo simplificado dentro de las llaves.

```{r funcion_escribir}

explorar_penguins <- function (var) {
  ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) +
    geom_point(position = position_jitterdodge(), alpha = 0.3) +
    geom_boxplot(alpha = 0.5) +
    scale_color_manual(values = c("turquoise", "goldenrod1")) +
    theme_light() +
    ylab(var) 
}

```

 Utiliza comentarios (#) para explicar el razonamiento detr谩s de tus funciones. Se debe evitar explicar qu茅 se est谩 haciendo o c贸mo, ya que el propio c贸digo ya lo comunica. Tambi茅n se recomienda usar \# para separar apartados (Cmd/Ctrl + Shift + R).

5.  Probar con entradas diferentes

```{r funcion_pruebas}

explorar_penguins(var = "body_mass_g") 
explorar_penguins(var = "flipper_length_mm") 
explorar_penguins(var = "bill_depth_mm")

```

#### Ejercicio

Genera una funci贸n para estandarizar (es decir, restar la media y dividir por la desviaci贸n t铆pica) las variables num茅ricas de penguins.

### Argumentos

En general hay dos grupos: los que especifican los **datos** y los que especifican **detalles** de la ejecuci贸n de la funci贸n. Normalmente los que especifican datos se colocan primero y los de detalle despu茅s. Estos 煤ltimos suelen tener valores por defecto (los m谩s comunes), para cuando no se especifique nada.

<!--# Ver ayuda de quantile -->

 Los nombres de los argumentos deben ser cortos y descriptivos. Hay algunos comunes pero poco descriptivos que ya son conocidos para la mayor铆a de los usuarios y est谩 bien aprovecharlos:

`x, y, z`: vectores

`w`: vector de pesos

`df`: data frame

`i, j`: indices numericos, filas y columnas respectivamente

`n`: longitud o n煤mero de filas

`p`: numero de columnas

`na.rm`: valores faltantes

### Valores de retorno

La 煤ltima expresi贸n ejecutada en una funci贸n es el valor de retorno.

 La funci贸n `return()` se usa para indicar explicitamente qu茅 se quiere obtener en una funci贸n. Se recomienda su uso cuando el retorno no se espera al final de la funci贸n. P. ej. en las ramas de una estructura `if-else`, sobre todo cuando hay alguna rama larga y compleja.

## Iteraciones con bucles *for*

Los bucles son recomendables para adentrarse en el mundo de las iteraciones porque hacen cada iteraci贸n muy expl铆cita para que quede claro lo que est谩 pasando.

![Representaci贸n gr谩fica del funcionamiento de los bucles *for* donde se ve claramente que se est谩 realizando una iteraci贸n. Ilustraci贸n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/forloops.png)

Para programar un bucle es necesario definir tres partes diferentes: la salida, la secuencia y el cuerpo.

```{r for}

set.seed(123)

df_ej <- data.frame(
  a = sample(1:5),
  b = sample(1:5),
  c = sample(1:5)
)

salida <- vector("double", 3)           # 1. salida
for (i in 1:3) {                        # 2. secuencia
  salida[[i]] <- first(df_ej[[i]])      # 3. cuerpo
}

salida

# podriamos generalizar el for
salida <- vector("double", ncol(df_ej))   # 1. salida
for (i in seq_along(df_ej)) {             # 2. secuencia
  salida[[i]] <- first(df_ej[[i]])        # 3. cuerpo
}

salida

# tambien podriamos iterar sobre filas
salida <- vector("double", nrow(df_ej)) 
for(i in 1:nrow(df_ej)) {
    salida[[i]] <- sum(df_ej[i, ])
}

salida

```

1.  Salida: aqu铆 determinamos el espacio de la salida, es decir, primero tenemos que crear la libreta donde vamos a ir apuntando todos los resultados.

2.  Secuencia: aqu铆 determinamos sobre lo que queremos iterar. Cada ejecuci贸n del bucle *for* asignar谩 un valor diferente de `seq_along(y)` a `i`.

3.  Cuerpo: aqu铆 determinamos lo que queremos que haga cada iteraci贸n. Se ejecuta repetidamente, cada vez con un valor diferente para `i`.

Existe la creencia de que los bucles *for* son lentos, pero la desventaja real de *los bucles for es que son demasiado flexibles* y pueden realizar muchas tareas diferentes. En cambio, cada funcional ({[purrr](https://purrr.tidyverse.org/)}, [`apply`](https://www.r-bloggers.com/2022/03/complete-tutorial-on-using-apply-functions-in-r/)) est谩 dise帽ado para una tarea espec铆fica, por lo que en cuanto lo ves en el c贸digo, inmediatamente sabes por qu茅 se est谩 utilizando. Es decir, la principal ventaja es su claridad al hacer que el c贸digo sea m谩s f谩cil de escribir y de leer.

Los bucles pueden ser m谩s expl铆citos en cuanto a que se ve claramente la iteraci贸n, pero se necesita m谩s tiempo para entender qu茅 se est谩 haciendo. Por el contrario, los funcionales necesitan un paso m谩s de abstracci贸n y pueden requerir tiempo hasta que los comprendamos. Lo m谩s importante es que soluciones el problema y poco a poco ir escribiendo c贸digo cada vez m谩s sencillo y elegante.

> Para ser significativamente m谩s fiable, el c贸digo debe ser m谩s transparente. En particular, las condiciones anidadas y los bucles deben considerarse con gran recelo. Las esctructuras de control complicados confunden a los programadores. El c贸digo desordenado suele ocultar errores.
>
> --- Bjarne Stroustrup ([Advanced R](https://adv-r.hadley.nz/index.html))

## Iteraciones con funcionales

![Representaci贸n gr谩fica del funcionamiento de `map()` donde el foco est谩 en la operaci贸n realizada. Ilustraci贸n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/map_frosting.png)

Un funcional es una funci贸n que toma una funci贸n como entrada y devuelve un vector u otro tipo de objeto como salida.

```{r ejemplo_funcional}

aleatorizacion <- function(f) {
  f(rnorm(5))
}

aleatorizacion(f = median)

```

Para programar un funcional, primero, solucionamos el problema para un elemento. Despu茅s, generamos una funci贸n que nos permita envolver la soluci贸n en una funci贸n (como lo hicimos en @sec-writefun). Por 煤ltimo, *aplicamos la funci贸n a todos los elementos que estamos interesados.* Es decir, dividimos los problemas grandes en problemas m谩s peque帽os y resolvemos cada tarea con una o m谩s funciones.

En *tidyverse* se iteran procesos mediante el paquete {purrr}. Comparando los funcionales con los bucles, el foco est谩 en la operaci贸n que se est谩 ejecutando, y no en el c贸digo necesario para iterar sobre cada elemento y guardar la salida.

```{r map_foco}

map(df_ej, first)

df_ej |> 
  map(first)

salida <- vector("list", length = 3)
for (i in 1:3) {
  salida[[i]] <- first(df_ej[[i]])
}
salida

```

### Nuestro primer funcional: generando listas, `map()`

`map_*()` est谩 vectorizado sobre un argumento, p. ej. `(x)`. La funci贸n operar谩 en todos los elementos de `x`, es decir, cada valor si `x` es un vector, cada columna si `x` es un `data.frame`, o cada elemento si `x` es una lista.

Toma un vector y una funci贸n, llama a la funci贸n una vez por cada elemento del vector y devuelve los resultados en una lista. `map(1:3, f)` es equivalente a `list(f(1), f(2), f(3))`. Es el equivalente de `lapply()` de R base.

```{r map_ejemplo}

cuadratica <- function(x) {
  x ^ 2
}

map_ouput_list <- map(.x = 1:4, .f = cuadratica)

lapply_ouput_list <- lapply(X = 1:4, FUN = cuadratica)

# seleccionar cada elemento de la lista
map_ouput_list[[1]]

map_ouput_list |>
  pluck(1)

# algun uso mas interesante 
glimpse(penguins)

# atajo para generar una funcion anonima:  \(nombre_del_argumento)
map(.x = penguins, .f = \(x) length(unique(x)))

# salida dataframe
map_df(.x = penguins, .f = \(x) length(unique(x)))

```

![](images/map.png)

#### Ejercicio

Generad un vector, una funci贸n y aplicadle la funci贸n a cada uno de los elementos del vector utilizando `map()`.

Los argumentos que var铆an para cada ejecuci贸n se ponen antes de la funci贸n y los argumentos que son los mismos para cada ejecuci贸n se ponen despu茅s (p. ej. `na.rm = T`).

![](images/map+fix.png)

Para incluir argumentos adicionales a la funci贸n que estamos utilizando dentro de `map()`, una opci贸n es decrararlo dentro de la funci贸n. Sin embargo, puesto que `map()` incluye `...` entre sus argumentos, tambi茅n podemos incluir los argumentos adicionales despu茅s de la funci贸n y dentro de `map()` de una forma mucho m谩s sencilla. Hay una peque帽a diferencia entre incluir argumentos adicionales dentro de una funci贸n e incluirlos directamente dentro del `map()`. Incluirlo en una funci贸n significa que se evaluar谩 cada vez que se ejecute la funci贸n, pero al incluirlo dentro de `map()` s贸lo se evaluar谩 una vez.

### Nuestro segundo funcional: generando vectores, `map_*()`

#### Ejercicio

Dedicadle un par de minutos a entender lo que hacen las siguientes funciones:

```{r map_vectores}

map_lgl(penguins, is.numeric)
penguins_num <- penguins[ , map_lgl(penguins, is.numeric)] 
map_dbl(penguins_num, median, na.rm = T)
map_chr(penguins, class)
map_int(penguins, \(x) length(unique(x)))
1:4 |> 
  map_vec(\(x) as.Date(ISOdate(x + 2024, 09, 25)))

```

### Nuestro tercer funcional: dos entradas, `map2()`

`map2()` est谩 vectorizado sobre dos argumentos, p. ej. `(x, y)`

```{r map2_ejemplo}

potencia <- function(base, exponente) {
  base ^ exponente
}

set.seed(123)

x <- sample(5)
y <- sample(5)

map2(x, y, potencia)

```

÷Importante! La primera iteraci贸n corresponde al primer valor del vector `x` y al primer valor del vector `y`. La segunda iteraci贸n corresponde al segundo valor del vector `x` y al segundo valor del vector `y`. No se hacen todas las combinaciones posibles entre ambos vectores.

![](images/map2.png)

#### Ejercicio {#sec-ejercicio-map2}

A partir del c贸digo que se muestra a continuaci贸n generad un `data.frame`, agregando una columna al `data.frame` con el nombre que le hemos asignado a cada lista.

```{r map_2_ejercicio}

penguins_list <- penguins |>
  group_split(species)

# asignamos nombres a las listas
names(penguins_list) <- c("p1", "p2", "p3")

```

Se puede iterar sobre m谩s de dos entradas con [`pmap()`](https://github.com/DatSciR/intro_prog_fun/blob/main/lleida/intro_prog_fun.md#nuestro-cuarto-funcional-m%C3%BAltiples-entradas-pmap), iterar cuando no hay un objeto de salida con [`walk()`](https://github.com/DatSciR/intro_prog_fun/blob/main/lleida/intro_prog_fun.md#iteraciones-sin-salida) e iterar sobre 铆ndices con [`imap()`](https://github.com/DatSciR/intro_prog_fun/blob/main/lleida/intro_prog_fun.md#m%C3%A1s-variantes-de-map-modify-e-imap), entre otras opciones.

### Enlaces de inter茅s

-   [R for data Science (functions)](https://r4ds.had.co.nz/functions.html)

-   [Advanced R (functions)](https://adv-r.hadley.nz/functions.html)

-   [R for data Science (iteration)](https://r4ds.had.co.nz/iteration.html)

-   [Advanced R (functionals)](https://adv-r.hadley.nz/functionals.html)

-   [purrr 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/)

-   [Learn to purrr (Rebecca Barter)](https://www.rebeccabarter.com/blog/2019-08-19_purrr)

------------------------------------------------------------------------

<details>

<summary>Session Info</summary>

```{r session_info}
Sys.time()
sessionInfo()
```

</details>
