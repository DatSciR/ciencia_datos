---
title: | 
  | Ciencia de datos en R ![](images/Escuela de Doctorado_trilingue_positivo.png){width=80%,fig-align="right"}
subtitle: "Organizando datos: el d铆a a d铆a"
author: Julen Astigarraga and Ver贸nica Cruz-Alonso
date: today
date-format: "DD/MM/YYYY"
toc: true
toc-title: "ndice"
format:
  html: default
    # css: styles.css
  gfm: default
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
---

## Objetivos y estructura

<!--# ja: empezaria siempre explicando lo que vamos a ver cada dia -->

Los **objetivos** del d铆a de hoy son:

-   aprender a escribir funciones

-   aplicar funciones en programaci贸n iterativa mediante el paquete {purrr} de {tidyverse}

Dentro del modelo de ciencia de datos de Hadley Wickham, Mine etinkaya-Rundel y Garrett Grolemund (@fig-datascience), el d铆a de hoy se centra en el marco que envuelve todo el proceso, es decir, la programaci贸n.

![Modelo de ciencia de datos de Hadley Wickham, Mine etinkaya-Rundel y Garrett Grolemund. Traducido de https://r4ds.hadley.nz/intro#fig-ds-diagram](images/datascience.png){#fig-datascience}

<!--# ja: esta tabla lo podemos modificar al final cuando tengamos la apuntes recortados ready -->

+------------------------------------------+---------------+
| Bloques                                  | D铆a           |
+==========================================+===============+
| Presentaci贸n del curso                   | 13/05/24      |
|                                          |               |
| Introducci贸n a la programaci贸n en R      |               |
|                                          |               |
| Introducci贸n a la programaci贸n funcional |               |
+------------------------------------------+---------------+
| Teor铆a sobre funciones en R              | 15/05/24      |
|                                          |               |
| C贸mo escribir funciones                  |               |
+------------------------------------------+---------------+
| Programaci贸n orientada a objetos         | 20/05/24      |
|                                          |               |
| Programaci贸n funcional                   |               |
|                                          |               |
| Iteraciones sobre uno y dos argumentos   |               |
+------------------------------------------+---------------+
| Iteraciones sobre m煤ltiples argumentos   | 22/05/24      |
|                                          |               |
| Iteraciones sin salida                   |               |
|                                          |               |
| Operadores y otros funcionales           |               |
+------------------------------------------+---------------+

<!--# ja: he quitado las secciones de arriba que eran mas bien de intro a r que lo he llevado a dia_1_intro o de tidyverse que lo he llevado a dia_1_organizando_datos -->

<!--# ja: me parece guay empezar un poco por el lexical scoping y demas este dia que ya es algo m谩s avanzado pero necesario para entender la prog fun. tambien tenemos que comparar con los apuntes de transmitting y a帽adir las mejoras del issue -->

Una diferencia fundamental entre R base y *tidyverse* importante para avanzar en este curso es que el *name masking* es diferente. En R, si un argumento no est谩 definido en una funci贸n, R buscar谩 ese nombre en el nivel del entorno inmediatamente superior. En general, con R base s贸lo podemos llamar a objetos que forman parte del entorno (env-variables); en cambio, con tidyverse se puede llamar tambi茅n a las variables dentro de las tablas (data-variables). Esta caracter铆stica simplifica el c贸digo en tidyverse, pero la ventaja no tiene coste cero y tiene implicaciones en la gram谩tica de las funciones como veremos m谩s adelante.

El [*lexical scoping* (谩mbito l茅xico)](https://adv-r.hadley.nz/functions.html?q=lexica#lexical-scoping) son el conjunto de normas sobre c贸mo los valores de las variables son extraidos del entorno en cada lenguaje de programaci贸n, es decir, como se asocia una variable a un valor. En R tiene cuatro normas b谩sicas, pero la m谩s importante para empezar con programaci贸n funcional es el *name masking*.

```{r name_masking}
#| warning: false
#| error: true

mean(x = 1:10)
mean(x = valores)
misdatos <- data.frame(valores = 1:10)
mean(x = valores)
mean(x = misdatos$valores)
misdatos |> 
  summarise(mean = mean(valores))


penguins |> filter(island == "Dream", species == "Chinstrap") |> select(flipper_length_mm)
penguins[penguins$island == "Dream" & penguins$species == "Chinstrap", "flipper_length_mm"]

```

## Introducci贸n a la programaci贸n funcional

<!--# ja: esta seccion creo que hemos quedado que la recortarias tu y yo la de las iteraciones :) -->

La creciente disponibilidad de datos y de versatilidad de los programas de an谩lisis han provocado el incremento en la cantidad y complejidad de los an谩lisis que realizamos en ecolog铆a. Esto hace cada vez m谩s necesaria la eficiencia en el proceso de gesti贸n y an谩lisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programaci贸n basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el c贸digo.

Se puede llamar a una funci贸n a trav茅s de otra funci贸n e iterar el proceso lo que hace que R sea una herramienta muy potente. Las **iteraciones** sirven para realizar la misma acci贸n a m煤ltiples entradas. Existen dos grandes paradigmas de iteraci贸n: la programaci贸n orientada a objetos y la programaci贸n funcional. En este taller, nos centraremos principalmente en la **programaci贸n funcional** y aprenderemos a utilizar el paquete {purrr}, que proporciona funciones para eliminar muchos bucles comunes.

```{r ejemplo_importancia_PF}
#| warning: false

df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

df_rescaled1 <- df |> 
  mutate(bill_length_mm = (bill_length_mm - min(bill_length_mm, na.rm = TRUE)) / (max(bill_length_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)),
    bill_depth_mm = (bill_depth_mm - min(bill_depth_mm, na.rm = TRUE)) / (max(bill_depth_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)),
    flipper_length_mm = (flipper_length_mm - min(flipper_length_mm, na.rm = TRUE)) / (max(flipper_length_mm, na.rm = TRUE) - min(flipper_length_mm, na.rm = TRUE)),
    body_mass_g = (body_mass_g - min(body_mass_g, na.rm = TRUE)) / (max(body_mass_g, na.rm = TRUE) - min(body_mass_g, na.rm = TRUE)))
    
View(df_rescaled1)

#
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1]) 
} 

df_rescaled2 <- df |> 
  mutate(bill_length_mm = rescale01(bill_length_mm),
    bill_depth_mm = rescale01(bill_depth_mm),
    flipper_length_mm = rescale01(flipper_length_mm), 
    body_mass_g = rescale01(body_mass_g))  

View(df_rescaled2)

#
df_rescaled3 <- lapply(df, rescale01)

head(df_rescaled3$bill_length_mm)

```

Las principales **ventajas de la programaci贸n funcional** (uso de funciones e iteraciones) son:

-   Facilidad para ver la intenci贸n del c贸digo y, por tanto, mejorar la **comprensi贸n** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El c贸digo queda m谩s ordenado.
-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.
-   **Disminuye la probabilidad de error**.

### 驴Cu谩ndo hay que usar una funci贸n?

Se recomienda seguir el principio "do not repeat yourself" ([DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.)): cada unidad de conocimiento o informaci贸n debe tener una representaci贸n 煤nica, inequ铆voca y autoritativa en un sistema.

Escribir una funci贸n ya merece la pena cuando has copiado y pegado m谩s de dos veces lo mismo. Cuantas m谩s veces est茅 repetido un c贸digo en m谩s sitios necesitar谩s actualizarlo si hay algun cambio y m谩s aumenta la probabilidad de error.

## Teor铆a sobre funciones en R

Las funciones tienen tres componentes:

-   `body()` (*cuerpo*): c贸digo dentro de la funci贸n.
-   `formals()`: lista de *argumentos* que controlan como se ejecuta la funci贸n.
-   `environment()`: la estructura que alimenta el *scoping* de la funci贸n, es decir, el *entorno* donde se ubica la funci贸n.

```{r componentes}

body(rescale01)
formals(rescale01)
environment(rescale01)

```

```{r environment}

f <- function(x) {
  x + y
}

y <- 100
f(x = 10)

y <- 1000
f(10)

```

Las **funciones primitivas** son la excepci贸n ya que no tienen los citados componentes. Est谩n escritas en C en lugar de en R y s贸lo aparecen en el paquete *base*. Son m谩s eficientes pero se comportan diferente a otras funciones, as铆 que R Core Team intenta no crear nuevas funciones primitivas. El resto de funciones siguen la estructura indicada arriba.

```{r funciones_primitivas}

sum
body(sum)

```

Seg煤n el tipo de output generado hay dos tipos de funciones:

-   Las **funciones de transformaci贸n** transforman el objeto que entra en la funci贸n (primer argumento) y devuelven otro objeto o el anterior modificado. Los funcionales son tipos especiales de funciones de transformaci贸n.

-   Las **funciones secundarias** (*side-effect functions*) tienen efectos colaterales y ejecutan una acci贸n, como guardar un archivo o dibujar un plot. Algunos ejemplos que se usan comunmente son: `library()`, `setwd()`, `plot()`, `write_delim()`... Estas funciones retornan *de forma invisible* el primer argumento, que no se guarda, pero puede ser usado en un *pipeline*.

En general, sint谩cticamente, las funciones tienen tres componentes:

-   Funci贸n `function()` (primitiva)
-   Argumentos: lista de entradas.
-   Cuerpo: trozo de c贸digo que sigue a `function()`, tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {
  paste(x, y, sep = "_")
}  

nombre1_v2 <- function(x, y) paste(x, y, sep = "_")  

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")  

nombre1_v1("Vero", "Cruz") 
nombre1_v2("Vero", "Cruz") 
nombre1_v3("Vero", "Cruz") 

```

 Si la funci贸n tiene m谩s de dos lineas es mejor usar llaves siempre para que quede bien delimitada. La llave de apertura nunca debe ir sola pero s铆 la de cierre (excepto con *else*). Las sangr铆as tambi茅n ayudan mucho a entender la jerarqu铆a del c贸digo dentro de las funciones. En este sentido recomendamos usar *Code \> Reindent lines/Reformat code* en el men煤 de RStudio.

Los operadores infijos (`+`), de flujo (`for`, `if`), de subdivisi贸n (`[ ]`, `$`), de reemplazo (`<-`) o incluso las llaves (`{ }`) tambi茅n son funciones. La tilde invertida "\`" permite referirse a funciones o variables que de otro modo tienen "nombre ilegales".

```{r nombres_ilegales}

3 + 2 
`+`(3, 2)  
for (i in 1:2) print(i) 
`for`(i, 1:2, print(i)) 
```

En general las funciones tienen un nombre que se ejecuta cuando se necesita como hemos visto hasta ahora, pero esto no es obligatorio. Algunos paquetes como {purrr} o las funciones de la familia `apply` permiten el uso de **funciones an贸nimas** para iterar.

```{r funciones_anonimas}

nxcaso <- lapply(penguins, function(x) length(unique(x)))

models <- penguins|>
  group_split(species) |>
  map(\(df) lm(body_mass_g ~ bill_length_mm, data = df)) 

```

 Mejor reservar el uso de funciones an贸nimas para funciones cortas y simples. Si la funci贸n es larga y ocupa varias l铆neas mejor darle un nombre.

## C贸mo escribir funciones

#### Ejercicio

Genera tu primera funci贸n que divida un valor siempre entre 100.

Atajo para escribir funciones: escribir la palabra fun + tabulador

Imaginad que para un set de datos quisieramos hacer un gr谩fico de distribuci贸n de cada variable num茅rica, en funci贸n de otra variable categ贸rica que nos interese especialmente, para ver c贸mo se distribuye.

```{r codigo_repetido_avanzado}
#| warning: false

penguins_num <- penguins |> 
  select(species, sex, where(is.numeric))

# nos interesan las diferencias entre especie y sexo

ggplot(penguins_num, aes(x = species, y = bill_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = bill_depth_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = flipper_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

# etc
```

Hemos copiado un c贸digo m谩s de dos veces para realizar una misma acci贸n (es decir, un gr谩fico para ver como se distribuye una variable en funci贸n de otras dos que se mantienen constantes) as铆 que hay que considerar la posibilidad de que estamos necesitando una funci贸n. A continuaci贸n vamos a seguir unos sencillos pasos para transformar cualquier c贸digo repetido en funci贸n.

1.  Analizar el c贸digo: 驴cu谩les son las partes replicadas? 驴cuantas entradas tenemos? 驴cu谩les var铆an y cu谩les no?

2.  Simplificar y reanalizar duplicaciones

```{r funcion_simplificar}
#| warning: false

var <- penguins_num$bill_length_mm

ggplot(penguins_num, aes(x = species, y = var, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()
 
```

```{r funcion_simplificar_2}
#| warning: false
#| error: true

var <- body_mass_g
var <- "body_mass_g"

ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light() +
  ylab(var)


```

 La funci贸n ggplot necesita argumentos (data-variable) que est茅n dentro del `data.frame` que va a representar. Para poder generalizar la funci贸n hemos guardado el nombre de la variable en un objeto (tipo *character*), pero ggplot no acepta "characters". Por ello necesitamos utilizar una funci贸n intermedia que s铆 los acepte.

 Crear objetos con c谩lculos intermedios dentro de una funci贸n, es una buena pr谩ctica porque deja m谩s claro lo que el c贸digo est谩 haciendo.

3.  Elegir un nombre para la funci贸n (). Idealmente tiene que ser corto y evocar lo que la funci贸n hace. En general, debe ser un verbo (p.e. imputar_valores) mientras que los argumentos son sustantivos (p.e. data, variable, etc.). Usar un sustantivo para una funci贸n est谩 permitido si la funci贸n calcula algo muy conocido (p.e. `mean()`) o si sirve para acceder a partes de un objeto (p.e. `residuals()`). Tambi茅n se recomienda evitar verbos muy gen茅ricos (p.e. calcular) y si el nombre tiene varias palabras separarlas con gui贸n bajo o may煤sculas, pero ser consistente. Si programas varias funciones que hacen cosas parecidas se recomienda usar el mismo prefijo para todas (p.e. "str\_" en el paquete {stringr}).

Cuanto m谩s claramente puedas expresar la intenci贸n de tu c贸digo a trav茅s de los nombres de funciones, m谩s f谩cilmente otros e incluyendo tu mismo en el futuro podr谩n leer y comprender el c贸digo.

```{r nombres_mal}

# Ejemplos de nombres que no hay que usar

T <- FALSE
c <- 10
mean <- function(x) sum(x)

rm(T, c, mean)

```

4.  Enumerar los argumentos dentro de `function()` y poner el c贸digo simplificado dentro de las llaves.

```{r funcion_escribir}

# Varias opciones

explorar_penguins <- function (var) {
  ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) +
    geom_point(position = position_jitterdodge(), alpha = 0.3) +
    geom_boxplot(alpha = 0.5) +
    scale_color_manual(values = c("turquoise", "goldenrod1")) +
    theme_light() +
    ylab(var) 
}

```

 Utiliza comentarios (#) para explicar el razonamiento detr谩s de tus funciones. Se debe evitar explicar qu茅 se est谩 haciendo o c贸mo, ya que el propio c贸digo ya lo comunica. Tambi茅n se recomienda usar \# para separar apartados (Cmd/Ctrl + Shift + R).

5.  Probar con entradas diferentes

```{r funcion_pruebas}

explorar_penguins(var = "body_mass_g") 
explorar_penguins(var = "flipper_length_mm") 
explorar_penguins(var = "bill_depth_mm")

```

Puedes querer convertir estas pruebas en **test** formales. En funciones complejas sirven para que, aunque hagas cambios, se pueda comprobar que la funcionalidad no se ha roto. Si est谩s interesado mira este enlace: [https://r-pkgs.org/testing-basics.html](#0){.uri}

#### Ejercicio

Genera una funci贸n para estandarizar (es decir, restar la media y dividir por la desviaci贸n t铆pica) las variables num茅ricas de penguins.

### Argumentos

En general hay dos grupos: los que especifican los **datos** y los que especifican **detalles** de la ejecuci贸n de la funci贸n. Normalmente los que especifican datos se colocan primero y los de detalle despu茅s. Estos 煤ltimos suelen tener valores por defecto (los m谩s comunes), para cuando no se especifique nada.

<!--# Ver ayuda de quantile -->

 Los nombres de los argumentos deben ser cortos y descriptivos. Hay algunos comunes pero poco descriptivos que ya son conocidos para la mayor铆a de los usuarios y est谩 bien aprovecharlos:

`x, y, z`: vectores

`w`: vector de pesos

`df`: data frame

`i, j`: indices numericos, filas y columnas respectivamente

`n`: longitud o n煤mero de filas

`p`: numero de columnas

`na.rm`: valores faltantes

A la hora de ejecutar la funci贸n los argumentos se pueden **especificar** utilizando el nombre completo, una abreviatura unequ铆voca o el 贸rden de su posici贸n (*unnamed arguments*), siendo esta secuencia (nombre \> abreviatura \> posici贸n) el 贸rden de prioridad a la hora de hacer corresponder los argumentos con lo que se escribe.

 Generalmente s贸lo se usa el orden de posici贸n para especificar los primeros argumentos, los m谩s comunes que todo el mundo conoce. Si se cambia un argumento de detalle con valor por defecto conviene poner siempre el combre completo.

 Usar espacios antes y despu茅s de `=` y despu茅s de `,` hace mucho m谩s f谩cil identificar los argumentos de la funci贸n y, en general, todos los componentes.

```{r espacios}

set.seed(123)
mean(rnorm(10, mean = 50, sd = 25) / 12, trim = 0.2)

set.seed(123)
mean(rnorm(10,mean=50,sd=25)/12,trim=0.2)

```

Hay un argumento especial llamado ``, que captura cualquier otro argumento que no se corresponde con los nombrados en la funci贸n. Se utiliza para transmitir argumentos a otras funciones incluidas en nuestra funci贸n.

```{r argumento_dotdotdot}
#| eval: false

?plot

plot(1:5, 1:5)

plot(1:5, 1:5, main = "Estoy usando argumentos de title()")

```

 Usar `` hace que las funciones sean muy flexibles, pero hace necesario leer cuidadosamente la documentaci贸n para poder usarlo. Adem谩s, si se escribe mal un argumento no sale error.

```{r dotdotdot_flexibilidad}

sum(1, 2, 5, na.mr = TRUE)
sum(1, 2, NA, na.mr = TRUE)

```

### Valores de retorno

La 煤ltima expresi贸n ejecutada en una funci贸n es el valor de retorno. Es el resultado de ejecutar la funci贸n, a no ser que se especifique `invisible()`. Las funciones arrojan un s贸lo objeto. Si se quieren obtener m谩s, tendr谩 que ser en formato de lista.

<!--# Se os ocurre alg煤n caso donde usar invisible? -->

 La funci贸n `return()` se usa para indicar explicitamente qu茅 se quiere obtener en una funci贸n. Se recomienda su uso cuando el retorno no se espera al final de la funci贸n. P.e. en las ramas de una estructura `if/else()` sobre todo hay alguna rama larga y compleja.

#### Ejercicio

驴C贸mo generalizar铆as la funci贸n `explorar_penguins()` para que te sirviera para cualquier base de datos?

## Programaci贸n orientada a objetos (POO)

La mayor铆a de la gente tiende a programar de forma imperativa. En la programaci贸n imperativa, los scripts tienden a ser largos y cambian gradualmente el estado del programa. Esto a menudo implica el uso de bases de datos temporales que se modifican a lo largo del proceso de an谩lisis. Como resultado, puede resultar m谩s dif铆cil comprender qu茅 se est谩 haciendo en cada paso del script. La programaci贸n orientada a objetos, utilizada por lenguajes como Java o Python, ha sido el paradigma de programaci贸n m谩s popular en las 煤ltimas d茅cadas y utiliza un estilo de programaci贸n imperativo.

```{r cambio_gradual}

mypenguins <- penguins |> 
  mutate(
    bill_volume_mm2 = (bill_length_mm * bill_depth_mm) / 2,
    female_penguin = case_when(
      sex == "female" & body_mass_g < 3600 ~ "small female",
      sex == "female" & body_mass_g >= 3600 ~ "big female",
      TRUE ~ NA)
  ) 

mypenguins |> 
  group_by(female_penguin) |> 
  summarise(body_mass_mean = mean(body_mass_g))

```

Los bucles for y bucles while (*for loops* y *while loops*) son recomendables para adentrarse en el mundo de las iteraciones porque hacen que cada iteraci贸n sea muy expl铆cita por lo que est谩 claro lo que est谩 ocurriendo.

![Representaci贸n gr谩fica del funcionamiento de los bucles for donde se ve claramente que se est谩 realizando una iteraci贸n. Ilustraci贸n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/forloops.png)

```{r for}

set.seed(123)

df_ej <- data.frame(
  a = sample(1:5),
  b = sample(1:5),
  c = sample(1:5)
)

salida <- vector("double", 3)           # 1. salida
for (i in 1:3) {                        # 2. secuencia
  salida[[i]] <- first(df_ej[[i]])      # 3. cuerpo
}

salida

# podriamos generalizar el for
salida <- vector("double", ncol(df_ej))   # 1. salida
for (i in seq_along(df_ej)) {             # 2. secuencia
  salida[[i]] <- first(df_ej[[i]])        # 3. cuerpo
}

salida

```

1.  Salida: aqu铆 determinamos el espacio de la salida, es decir, primero tenemos que crear la libreta donde vamos a ir apuntando todos los resultados. Esto es muy importante para la eficiencia puesto que si aumentamos el tama帽o del *for loop* en cada iteraci贸n con `c()` u otra funci贸n que vaya a帽adiendo elementos, el bucle for ser谩 mucho m谩s lento.

```{r optimizacion}

x <- c()
system.time(
  for(i in 1:20000) {
    x <- c(x, i)
  }
)

y <- vector("double", length = 20000)
system.time(
  for(i in seq_along(y)) {
    y[i] <- i
  }
)

```

2.  Secuencia: aqu铆 determinamos sobre lo que queremos iterar. Cada ejecuci贸n del bucle for asignar谩 un valor diferente de `seq_along(y)` a *i* .

3.  Cuerpo: aqu铆 determinamos lo que queremos que haga cada iteraci贸n. Se ejecuta repetidamente, cada vez con un valor diferente para `i`.

Existen distintas [variaciones de los bucles for](https://r4ds.had.co.nz/iteration.html#for-loop-variations): (i) modificar un objeto existente en lugar de crear un nuevo; (ii) bucles sobre nombres o valores en lugar de sobre 铆ndices; (iii) bucles cuando desconocemos la longitud de la salida; (iv) bucles cuando desconocemos la longitud de la secuencia de entrada, es decir, bucles while.

 Algunos [errores comunes](https://adv-r.hadley.nz/control-flow.html) cuando se utilizan bucles for (ver 5.3.1 Common pitfalls).

A pesar de ser muy utilizados en R, los bucles for no son tan importantes como pueden ser en otros lenguajes porque R es un lenguaje de programaci贸n funcional. Esto significa que *es posible envolver los bucles for en una funci贸n* y llamar a esa funci贸n en vez de utilizar el bucle.

Existe la creencia de que los bucles for son lentos, pero la desventaja real de *los bucles for es que son demasiado flexibles*. En cambio, cada funcional ({purrr}, `apply`) est谩 dise帽ado para una tarea espec铆fica, por lo que en cuanto lo ves en el c贸digo, inmediatamente sabes por qu茅 se est谩 utilizando. Es decir, la principal ventaja es su claridad al hacer que el c贸digo sea m谩s f谩cil de escribir y de leer (ver este ejemplo avanzado para entenderlo: <https://adv-r.hadley.nz/functionals.html>, 9.3 Purrr style). Una vez que dominemos la programaci贸n funcional, podremos solventar muchos problemas de iteraci贸n con menos c贸digo, m谩s facilidad y menos errores.

Los bucles pueden ser m谩s expl铆citos en cuanto a que se ve claramente la iteraci贸n, pero se necesita m谩s tiempo para entender qu茅 se est谩 haciendo. Por el contrario, los funcionales necesitan un paso m谩s de abstracci贸n y pueden requerir tiempo hasta que los comprendamos. Lo m谩s importante es que soluciones el problema y poco a poco ir escribiendo c贸digo cada vez m谩s sencillo y elegante. Ver @sec-POO para obtener m谩s informaci贸n sobre programaci贸n orientada a objetos.

> Para ser significativamente m谩s fiable, el c贸digo debe ser m谩s transparente. En particular, las condiciones anidadas y los bucles deben considerarse con gran recelo. Las esctructuras de control complicados confunden a los programadores. El c贸digo desordenado suele ocultar errores.
>
> --- Bjarne Stroustrup ([Advanced R](https://adv-r.hadley.nz/index.html))

## Programaci贸n funcional

![Representaci贸n gr谩fica del funcionamiento de `map()` donde el foco est谩 en la operaci贸n realizada. Ilustraci贸n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/map_frosting.png)

En la programaci贸n funcional, las funciones est谩n dise帽adas para realizar una 煤nica tarea espec铆fica y luego se combinan llamando a estas funciones sucesivamente para el conjunto de datos. Una ventaja significativa de este enfoque es que estas funciones pueden ser reutilizadas en cualquier otro proyecto, lo que facilita la modularidad del c贸digo. Adem谩s, cuando est谩n bien documentadas y son f谩cilmente testables, resulta sencillo comprender y mantener el programa.

R es un lenguaje de programaci贸n funcional por lo que se basa principalmente en un estilo de resoluci贸n de problemas centrado en funciones (<https://adv-r.hadley.nz/fp.html>). Un funcional es una funci贸n que toma una funci贸n como entrada y devuelve un vector u otro tipo de objeto como salida.

```{r ejemplo_funcional}

aleatorizacion <- function(f) {
  f(rnorm(5))
}

aleatorizacion(f = median)

```

Para programar un funcional, primero, solucionamos el problema para un elemento. Despu茅s, generamos una funci贸n que nos permita envolver la soluci贸n en una funci贸n. Por 煤ltimo, *aplicamos la funci贸n a todos los elementos que estamos interesados.* Es decir, dividimos los problemas grandes en problemas m谩s peque帽os y resolvemos cada tarea con una o m谩s funciones.

La ventaja de utilizar {purrr} en vez de bucles for es que ofrece una funci贸n (funcional) para cada uno de los problemas comunes de manipulaci贸n de datos y, por lo tanto, cada bucle for tiene su propia funci贸n. Por ejemplo, para iterar sobre un argumento utilizamos la funci贸n `map()` y para iterar sobre dos argumentos la funcion `map2()`. La familia `apply` de R base soluciona problemas similares, pero {purrr} es m谩s consistente y, por lo tanto, m谩s f谩cil de aprender.

Iteracionar sobre un vector es tan com煤n que el paquete {purrr} proporciona una familia de funciones (la familia `map()`) para ello. Recordad que los data frames son listas de vectores de la misma longitud por lo que cualquier c谩lculo por filas o columnas supone iteracionar sobre un vector. Existe una funci贸n en {purrr} para cada tipo de salida. Los sufijos indican el tipo de salida que queremos:

-   `map()` genera una lista.
-   `map_lgl()` genera un vector l贸gico.
-   `map_int()` genera un vector de n煤meros enteros.
-   `map_dbl()` genera un vector de n煤meros decimales.
-   `map_chr()` genera un vector de caracteres.
-   `map_vec()` genera un tipo arbitrario de vector, como fechas y factores.

÷[Por qu茅 est谩 funci贸n se llama *map*](https://adv-r.hadley.nz/functionals.html#map)?

```{r map_foco}

map_int(df_ej, first)

df_ej |> 
  map_int(first)

salida <- vector("double", 3)
for (i in 1:3) {
  salida[[i]] <- first(df_ej[[i]])
}
salida

```

Comparando con un bucle, el foco est谩 en la operaci贸n que se est谩 ejecutando (`first()`), y no en el c贸digo necesario para iterar sobre cada elemento y guardar la salida.

## Iteraciones sobre un argumento

`map_*()` est谩 vectorizado sobre un argumento, p. ej. `(x)`. La funci贸n operar谩 en todos los elementos de `x`, es decir, cada valor si `x` es un vector, cada columna si `x` es un `data.frame`, o cada elemento si `x` es una lista.

### Nuestro primer funcional: generando listas, `map()`

Toma un vector y una funci贸n, llama a la funci贸n una vez por cada elemento del vector y devuelve los resultados en una lista. `map(1:3, f)` es equivalente a `list(f(1), f(2), f(3))`. Es el equivalente de `lapply()` de R base.

```{r map_ejemplo}

cuadratica <- function(x) {
  x ^ 2
}

map(1:4, cuadratica)

lapply(X = 1:4, FUN = cuadratica)

# algun uso mas interesante 
glimpse(penguins)

# atajo para generar una funcion anonima
map(penguins, \(x) length(unique(x)))

# salida dataframe
map_df(penguins, \(x) length(unique(x)))

```

![](images/map.png)

#### Ejercicio

Generad un vector, una funci贸n y aplicadle la funci贸n a cada uno de los elementos del vector utilizando `map()`.

```{r map_implementacion}

imple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}

imple_map(1:4, cuadratica)

```

Las funciones de {purrr} est谩n escritas en C para maximizar el rendimiento, conserva los nombres y admite algunos atajos (e.g. `\(x)`).

#### Ejercicio

Ahora que hab茅is entendido la l贸gica de `map()`, detectad las diferencias entre las tres l铆neas de c贸digo siguientes. 驴Qu茅 es lo que hace el funcional `map()`? 驴Qu茅 diferencias detect谩is en el c贸digo? 驴Y en la salida?

```{r argumentos_adicionales}

map(penguins, \(x) mean(x))
map(penguins, \(x) mean(x, na.rm = T)) # opcion 1
map(penguins, mean, na.rm = T) # opcion 2

```

Como hemos visto en el ejercicio anterior, si quisi茅ramos pasar argumentos adicionales a la funci贸n que estamos utilizando dentro de `map()`, una opci贸n ser铆a mediante una funci贸n an贸nima (ver opci贸n 1 del ejercicio anterior). Sin embargo, puesto que `map()` incluye `...` entre sus argumentos, tambi茅n podemos incluir los argumentos adicionales despu茅s de la funci贸n que est谩 dentro de `map()` de una forma mucho m谩s sencilla (ver opci贸n 2 del ejercicio anterior).

### Nuestro segundo funcional: generando vectores, `map_*()`

#### Ejercicio

Dedicadle un par de minutos a entender lo que hacen las siguientes funciones:

```{r map_vectores}

map_lgl(penguins, is.numeric)
penguins_num <- penguins[ , map_lgl(penguins, is.numeric)] 
map_dbl(penguins_num, median, na.rm = T)
map_chr(penguins, class)
map_int(penguins, \(x) length(unique(x)))
1:4 |> 
  map_vec(\(x) as.Date(ISOdate(x + 2024, 05, 13)))

```

Los argumentos que var铆an para cada ejecuci贸n se ponen antes de la funci贸n y los argumentos que son los mismos para cada ejecuci贸n se ponen despu茅s (p. ej. `na.rm = T`).

![](images/map+fix.png)

R base tiene dos funciones de la familia `apply()` que pueden devolver vectores: `sapply()` y `vapply()`. Recomendamos evitar `sapply()` porque intenta simplificar el resultado y elige un formato de salida por defecto, pudiendo devolver una lista, un vector o una matriz. `vapply()` es m谩s seguro porque permite indicar el formato de salida con FUN.VALUE. La principal desventaja de `vapply()` es que se necesitan especificar m谩s argumentos que en `map_*()`.

```{r vapply}

vapply(penguins_num, median, na.rm = T, FUN.VALUE = double(1))

```

Trabajar con listas es muy com煤n en R. De echo el output por defecto de `map()` son listas. Sin embargo, las listas pueden resultar a veces desordenadas, p. ej., cuando perdemos el nombre de cada elemento de la lista. La funci贸n [`nest()`](https://tidyr.tidyverse.org/reference/nest.html) de {tidyr} nos permite trabajar con listas-columnas en data frames, generando una fila para cada grupo definido por las columnas no anidadas (es decir, *non-nested* columns).

```{r map_ejemplo_avanzado}

glimpse(penguins)

# quitamos na's
penguins_nona <- penguins |>
  drop_na()

penguins_nested <- penguins_nona |>
  group_by(species) |>
  nest() |> # nest() genera lista-columna en data frames
  mutate(
    lm_obj = map(data, \(df) lm(
      bill_length_mm ~ body_mass_g,
      data = df))
  )

# seleccionar cada elemento de la lista
penguins_nested[["lm_obj"]]

penguins_nested |>
  pluck("lm_obj")

```

## Iteraciones sobre m煤ltiples argumentos

### Nuestro tercer funcional: dos entradas, `map2()`

`map2()` est谩 vectorizado sobre dos argumentos, p. ej. `(x, y)`

```{r map2_ejemplo}

potencia <- function(base, exponente) {
  base ^ exponente
}

set.seed(123)

x <- sample(5)
y <- sample(5)

map2(x, y, potencia)

```

÷Importante! La primera iteraci贸n corresponde al primer valor del vector `x` y al primer valor del vector `y`. La segunda iteraci贸n corresponde al segundo valor del vector `x` y al segundo valor del vector `y`. No se hacen todas las combinaciones posibles entre ambos vectores.

![](images/map2.png)

```{r map2_implementacion}

imple_map2 <- function(x, y, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], y[[i]], ...)
  }
  out
}

imple_map2(x, y, potencia)

```

#### Ejercicio {#sec-ejercicio-map2}

A partir del c贸digo que se muestra a continuaci贸n generad un `data.frame`, agregando una columna al `data.frame` con el nombre que le hemos asignado a cada lista.

```{r map_2_ejercicio}

penguins_list <- penguins |>
  group_split(species)

# asignamos nombres a las listas
names(penguins_list) <- c("p1", "p2", "p3")

```

```{r map2_ejemplo_avanzado}

penguins_nested <- penguins |>
  group_by(species) |>
  nest() |> 
  mutate(
    lm_obj = map(data, \(df) lm(
      bill_length_mm ~ body_mass_g,
      data = df)),
    pred = map2(lm_obj, data,
                \(x, y) predict(x, y))
  )

# unnest()
penguins_nested |> 
  unnest(pred) |> 
  select(!c(data, lm_obj))

```

#### Ejercicio avanzado

Calculad la correlaci贸n entre las predicciones guardadas en la lista-columna `pred` y `bill_length_mm`.

### Nuestro cuarto funcional: m煤ltiples entradas, `pmap()`

Toma una lista con cualquier n煤mero de argumentos de entrada.

```{r pmap_ejemplo}

# son analogos
map2(x, y, potencia)

pmap(list(x, y), potencia)

set.seed(123)

z <- sample(5)

?rnorm

pmap(list(n = x, mean = y, sd = z), rnorm)

```

Si no nombramos los elementos de la lista, `pmap()` usar谩 los elementos de la lista en su orden para los argumentos consecutivos de la funci贸n. De todas formas, es una buena pr谩ctica nombrarlos para que quede muy claro lo que har谩 la funci贸n.

```{r pmap_ejemplo_pipe}

args3 <- list(mean = x, sd = y, n = z) 

args3 |> 
  pmap(rnorm)

```

![](images/pmap.png)

#### Ejercicio

Transformad el `map2()` que hab茅is generado en el ejercicio @sec-ejercicio-map2 a `pmap()`.

## Iteraciones sin salida

### Nuestro quinto funcional: `walk()`, `walk2()` y `pwalk()`

Cuando queremos utilizar funciones por sus efectos secundarios (*side effects*, p. ej. `ggsave()`) y no por su valor resultante. Lo importante es la acci贸n y no el valor u objeto resultante en R.

#### Ejercicio

En base a lo que dice en la definici贸n sobre la familia `walk()`, corred este c贸digo y entended lo que hace.

```{r walk_ejercicio}

penguins_nested <- penguins |>
  group_by(species) |>
  nest()

# penguins_nested |> 
#   pluck("data") |> 
#   pluck(1)

penguins_nested_str <- penguins_nested |> 
  mutate(path = str_glue("penguins_{species}.csv"))

penguins_nested_str

walk2(penguins_nested_str$data, penguins_nested_str$path, write_csv)

```

#### Ejercicio avanzado

Generad un ejemplo donde utiliceis `walk2()` o `pwalk()` para guardar m煤ltiples plot generados con `ggplot()`. Pista: la primera entrada ser谩 el plot que quer茅is guardar y la segunda el nombre del archivo que le quer茅is dar.

## Operadores y otros funcionales

### M谩s variantes de `map()`

#### `modify()` e `imap()`

`modify()` e `imap()` tambi茅n son funcionales de la familia map. `modify()` es an谩logo a `map()` pero devuelve el mismo tipo de resultado que el tipo de entrada.

`imap()` sirve para iterar sobre indices, tanto indices num茅ricos como nombres. `imap(x, f)` es an谩logo a `map2(x, names(x), f)` cuando `x` tiene nombres y `map2(x, seq_along(x), f)` cuando no los tiene.

```{r modify_imap}

# modify
map(1:4, cuadratica)

modify(1:4, cuadratica)


# imap
map2(penguins, names(penguins), \(x, y) paste("La columna", y, "tiene", length(unique(x)), "valores unicos contando los NA's"))

imap(penguins, \(x, y) paste("La columna", y, "tiene", length(unique(x)), "valores unicos contando los NA's"))

df_ej <- data.frame(
  a = sample(1:5),
  b = sample(1:5),
  c = sample(1:5)
) 

colnames(df_ej) <- NULL

imap(df_ej, \(x, y) paste("La columna", y, "tiene", length(unique(x)), "valores unicos contando los NA's"))

```

En este curso no profundizamos en `modify()` e `imap()` porque con los dem谩s funcionales que hemos visto podemos abordar pr谩cticamente todos los problemas de iteraci贸n. Sin embargo, si alguien est谩 interesado puede consultar <https://adv-r.hadley.nz/functionals.html>, 9.4 Map variants.

Ejemplos de algunas tareas espec铆ficas con {purrr}: <https://r4ds.hadley.nz/iteration>

### Funcionales predicate y dem谩s

Los predicados son funciones que devuelven un solo TRUE o FALSE (p. ej., `is.character()`). As铆, un predicado funcional aplica un predicado a cada elemento de un vector: `keep()`, `discard()`, `some()`, `every()`, `detect()`, `detect_index()`... Para m谩s informaci贸n ver: <https://r4ds.had.co.nz/iteration.html>, 21.9.1 Predicate functions.

```{r ejemplo_predicado_funcional}

penguins |> 
  keep(is.numeric)

penguins |> 
  discard(is.numeric)

penguins |> 
  every(is.numeric)

```

`dplyr::across()` es similar a `map()` pero en lugar de hacer algo con cada elemento de un vector, data frame o lista, hace algo con cada columna en un data frame.

`reduce()` es una forma 煤til de generalizar una funci贸n que funciona con dos entradas (funci贸n binaria) para trabajar con cualquier n煤mero de entradas.

```{r extra}

penguins_scaled <- penguins |>
  mutate(across(where(is.numeric), scale))

ls <- list(
  age = tibble(name = c("Vero", "Julen"), age = c(100, 140)),
  sex = tibble(name = c("Vero", "Julen"), sex = c("F", "M")),
  height = tibble(name = c("Vero", "Julen"), height = c("180", "150"))
)

ls |> 
  reduce(full_join, by = "name")

```

#### Operadores funcionales

Cuando utilizamos las funciones `map()` para repetir muchas operaciones, aumenta la probabilidad de que una de esas operaciones falle y no obtengamos ninguna salida. {purrr} proporciona algunos operadores funcionales (*function operators*) en forma de adverbios para asegurar que un error no arruine todo el proceso: `safely()`, `possibly()`, `quietly()`. Para m谩s informaci贸n ver: <https://r4ds.had.co.nz/iteration.html>, 21.6 Dealing with failure.

```{r ejemplo_operador_funcional}
#| error: true

x <- list(10, "b", 3)

x |> 
  map(log)

x |> 
  map(safely(log))

x |> 
  map(safely(log)) |> 
  transpose()

x |> 
  map(possibly(log, NA_real_))

```

##### Ejercicio

Aplicad cualquier variante de `map()` junto con un operador funcional a la base de datos penguins.

## M谩s informaci贸n

### Paralelizaci贸n

Se pueden emplear distintos n煤cleos de la CPU (*Central Processing Unit*) para ejecutar el mismo proceso con diferentes conjuntos de datos en paralelo, lo que acelera tareas largas. Algunas tareas son especialmente adecuadas para la paralelizaci贸n, como aquellas que son repetitivas y tienen poca o ninguna dependencia entre s铆, salvo el origen de los datos de entrada, lo que permite dividirlas f谩cilmente en tareas paralelas. Estas tareas suelen ser aquellas que pueden ser resueltas mediante iteraciones como las que hemos visto anteriormente. En teor铆a, el proceso se acelera en proporci贸n al n煤mero de cores no, pero en la pr谩ctica, hay que tener en cuenta otros factores como el tiempo consumido en transferir datos a cada proceso y el tiempo dedicado a reunir los resultados de los diferentes procesos.

R fue dise帽ado originalmente para ejecutarse en un solo proceso de CPU debido a que cuando se desarroll贸, las CPU en general ten铆an un 煤nico n煤cleo y la computaci贸n paralela no era tan com煤n o no estaba tan desarrollada como lo est谩 hoy en d铆a. Por lo tanto, para aprovechar la paralelizaci贸n en R, necesitamos recurrir a paquetes adicionales. Sin embargo, es importante tener en cuenta que estos paquetes pueden estar limitados en su uso a casos y tipos de datos espec铆ficos.

```{r paralelizacion}
#| eval: false

library(parallel) # detectar numero de cores
library(future) # establecer numero de cores
library(furrr) # paralelizacion con map

detectCores()

# funcion para elevar al cubo un numero
cubo <- function(x) {
  Sys.sleep(1) # simulacion tarea computacionalmente intensiva
  return(x ^ 3)
}

# secuencial
tiempo_inicio <- Sys.time()
resultado <- map(1:10, cubo)
tiempo_final <- Sys.time()
cat("Tiempo de computaci贸n:", round(tiempo_final - tiempo_inicio, 1), "segundos")

# establecer como vamos a resolver el proceso
# aqui utilizaremos 3 nucleos pero en funcion del numero de nucleos disponibles en tu pc se puede modificar
plan(multisession, workers = 3)

# future_map para ejecutarlo paralelamente
tiempo_inicio <- Sys.time()
resultado <- future_map(1:10, cubo)
tiempo_final <- Sys.time()
cat("Tiempo de computaci贸n:", round(tiempo_final - tiempo_inicio, 1), "segundos")

# vemos que el tiempo de computacion se ha reducido casi a un 1/3 (aprox. 1/numero de cores)

```

La informaci贸n aqu铆 expuesta sobre programaci贸n paralela est谩 mucho m谩s ampliamente explicada en: <https://emf.creaf.cat/workflows/r_parallel_computing_tech_doc/>

### M谩s informaci贸n sobre programaci贸n orientada a objetos (POO) {#sec-POO}

> \- Todo lo que existe es un objeto.
>
> --- John Chambers
>
> \- Sin embargo, no todo es orientado a objetos

En R, la programaci贸n funcional suele ser m谩s relevante que la POO, ya que frecuentemente se abordan problemas complejos descomponi茅ndolos en funciones simples en lugar de objetos simples.

La principal raz贸n para utilizar la POO es el polimorfismo (del lat铆n "muchas formas"). El polimorfismo permite a un desarrollador considerar la interfaz de una funci贸n por separado de su implementaci贸n, lo que facilita el uso de la misma funci贸n con diferentes tipos de entrada. Para entender esto, probad a correr el siguiente c贸digo.

```{r polimorfismo}

summary(penguins$bill_depth_mm)
summary(penguins$sex)

```

Podr铆as pensar que `summary()` utiliza una serie de declaraciones `if-else` seg煤n el tipo de los datos de entrada, pero en este caso solo el autor original podr铆a a帽adir nuevas implementaciones. Sin embargo, un sistema de POO permite que cualquier desarrollador extienda la interfaz mediante la creaci贸n de implementaciones para nuevos tipos de entrada.

En los sistemas de POO, el tipo de un objeto se denomina su clase y una implementaci贸n espec铆fica para una clase se conoce como m茅todo. En t茅rminos generales, una clase define las caracter铆sticas de un objeto (驴qu茅 es?) y los m茅todos describen las acciones que ese objeto puede realizar (驴qu茅 hace?).

R base proporciona tres sistemas de POO (S3 que es la m谩s utilizada-, S4 y RC), aunque tambi茅n existen otros sistemas POO proporcionados por diferentes paquetes del CRAN.

```{r objetos}

library(sloop)

is.object(1:5) # objeto base pero no orientada a objetos
otype(1:5) # objeto base 
attr(1:5, "class") # no tienen clase

is.object(penguins) # orientada a objetos
otype(penguins) # S3
attr(penguins, "class") # tienen clase

ftype(summary) # funcion generica S3
# una funcion generica define la interfaz, que utiliza una implementacion (metodo) diferente dependiendo de la clase del argumento. Acuerdate de la idea del polimorfismo que hemos visto antes ;)

```

Informaci贸n m谩s detallada sobre [POO](https://adv-r.hadley.nz/oo.html) y [compromisos entre algunos sistemas de POO](https://adv-r.hadley.nz/oo-tradeoffs.html)

### Enlaces de inter茅s

-   [Hands-On Programming with R (basics)](https://rstudio-education.github.io/hopr/basics.html)

-   [R for data Science (functions)](https://r4ds.had.co.nz/functions.html)

-   [Advanced R (functions)](https://adv-r.hadley.nz/functions.html)

-   [R for data Science (iteration)](https://r4ds.had.co.nz/iteration.html)

-   [Advanced R (functionals)](https://adv-r.hadley.nz/functionals.html)

-   [purrr 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/)

-   [Learn to purrr (Rebecca Barter)](https://www.rebeccabarter.com/blog/2019-08-19_purrr)

-   [Style guide](http://adv-r.had.co.nz/Style.html)

-   [Quince consejos para mejorar nuestro c贸digo y flujo de trabajo con R](https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2129)

-   [Parallel computation in R](https://emf.creaf.cat/workflows/r_parallel_computing_tech_doc/)

-   [Advanced R (Object-oriented programming)](https://adv-r.hadley.nz/oo.html)

Este curso est谩 principalmente basado en la primera edici贸n del libro [R for Data Science](https://r4ds.had.co.nz/) de Hadley Wickham & Garrett Grolemund y la segunda edici贸n del libro [Advanced R](https://adv-r.hadley.nz/index.html) de Hadley Wickham.

------------------------------------------------------------------------

<details>

<summary>Session Info</summary>

```{r session_info}
Sys.time()
sessionInfo()
```

</details>
