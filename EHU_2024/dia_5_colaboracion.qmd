---
title: | 
  | Ciencia de datos en R ![](images/Escuela de Doctorado_trilingue_positivo.png){width=80%,fig-align="right"}
subtitle: "Organizando datos: el d√≠a a d√≠a"
author: Julen Astigarraga and Ver√≥nica Cruz-Alonso
date: today
date-format: "DD/MM/YYYY"
toc: true
toc-title: "√çndice"
format:
  html:
    link-external-newwindow: true
    # css: styles.css
  gfm: default
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
---

## 

# Introducci√≥n

El principal objetivo de este documento es dar a conocer la estructura, funcionalidad y potencialidad de Git (<https://git-scm.com/>), as√≠ como su interacci√≥n con GitHub (<https://github.com/>), para el trabajo en proyectos colaborativos y reproducibles. Ambas herramientas est√°n ganando cada vez m√°s importancia en diversos campos de estudio a medida que el volumen de datos aumenta y los an√°lisis se hacen m√°s complejos. Aprenderemos c√≥mo Git puede usarse para controlar la trazabilidad de los cambios realizados en proyectos o archivos y veremos c√≥mo este control de versiones es especialmente √∫til en proyectos colaborativos mediante el uso de un servidor de alojamiento en l√≠nea como GitHub. Aunque existen multitud de manuales disponibles gratuitamente sobre c√≥mo utilizar Git y GitHub, estas herramientas son complejas y tienen una curva de aprendizaje pronunciada. Por ello, aqu√≠ hemos intentado agrupar nuestra experiencia adquirida despu√©s de varios a√±os trabajando con estas herramientas para facilitar vuestra curva de aprendizaje ¬°Vamos a por ello!

Por ejemplo, Git y GitHub nos pueden ayudar a solucionar algunos problemas comunes derivados de la creaci√≥n de diferentes versiones que pueden ser un poco molestos:

\- Sobreescritura de un archivo

\- Versiones finales infinitas

!["FINAL.doc"](images/FINALdoc.png)

\- Trabajo por error en una versi√≥n que no era la final

\- Creaci√≥n de copias "en conflicto" cuando dos personas trabajan a la vez

\- Ediciones sin control de cambios

![Ediciones sin control de cambios](images/tracker.png)

## [Qu√© es Git](https://git-scm.com/)

Git es un sistema avanzado de control de versiones (como el "control de cambios" de Microsoft Word) distribuido [@blischak2016; @ram2013]. Git permite "rastrear" el progreso de un proyecto a lo largo del tiempo ya que hace "capturas" del mismo a medida que evoluciona y los cambios se van registrando. Esto permite ver qu√© cambios se hicieron, qui√©n los hizo y por qu√©, e incluso volver a versiones anteriores. Adem√°s, Git facilita el trabajo en paralelo de varios participantes. Mientras que en otros sistemas de control de versiones (p. ej. Subversion (SVN, <https://subversion.apache.org/>) o Concurrent Versions System (CVS, <http://cvs.nongnu.org/>)) hay un servidor central y cualquier cambio hecho por un usuario se sincroniza con este servidor y de ah√≠ con el resto de usuarios, Git es un control de versiones distribuido que permite a todos los usuarios trabajar en el proyecto paralelamente e ir haciendo "capturas" del trabajo de cada uno para luego unirlos. Otras alternativas de control de versiones distribuido comparables a Git son Mercurial (<https://www.mercurial-scm.org/>) o Bazaar (<https://bazaar.canonical.com/>), pero Git es con diferencia el m√°s utilizado.

Git surge en 2005, tras la ruptura de la relaci√≥n entre la comunidad que estaba desarrollando Linux y la empresa comercial que desarrollaba BitKeeper (DVCS). En ese momento BitKeeper dej√≥ de ser gratuita y esto llev√≥ a la comunidad de desarrolladores de Linux (y en particular a Linus Torvalds, el creador de Linux) a desarrollar su propia herramienta para el control de versiones bas√°ndose en su experiencia al utilizar BitKeeper. Algunos de los objetivos del nuevo sistema eran velocidad, dise√±o sencillo, gran soporte para el desarrollo no lineal (ramas), sistema distribuido y capacidad para manejar grandes bases de datos. Por tanto, el prop√≥sito original de Git era ayudar a grupos de desarrolladores inform√°ticos a trabajar en colaboraci√≥n en grandes proyectos de software. En este sentido, veremos que hay m√∫ltiples soluciones para un mismo problema y que la curva de aprendizaje para no desarrolladores puede ser pronunciada.

![Ejemplo de un proyecto rastreado por Git con indicaciones de c√≥mo se registran los cambios y la evoluci√≥n del proyecto, el autor o autora de los cambios (¬øqui√©n?), el momento en que se han registrado (¬øcu√°ndo?), en qu√© documentos o l√≠neas se han producido cambios (¬ød√≥nde?) y qu√© ha cambiado (¬øqu√©?)](images/git.jpg)

## [Qu√© es GitHub](https://github.com/)

GitHub es un servidor de alojamiento en l√≠nea o repositorio remoto para albergar proyectos basados en Git que permite la colaboraci√≥n entre diferentes usuarios o con uno mismo [@galeano2018; @perez-riverol2016]. Un repositorio es un directorio donde desarrollar un proyecto que contiene todos los archivos necesarios para el mismo. Aunque existen distintos repositorios remotos (p. ej. GitLab, <https://gitlab.com/>, o Bitbucket, <https://bitbucket.org/>) con funcionalidad similar, GitHub es hoy en d√≠a el m√°s utilizado. GitHub registra el desarrollo de los proyectos de manera remota, permite compartir proyectos entre distintos usuarios y proporciona la seguridad de la nube entre otras funciones. Cuando se trabaja en proyectos colaborativos, la base de la interacci√≥n entre Git y GitHub es que todos los colaboradores de un proyecto est√°n de acuerdo en que GitHub contiene la copia principal del proyecto, es decir, GitHub contiene la copia centralizada del control de versiones distribuido o descentralizado.

![P√°gina inicial de GitHub](images/github_pag_ini.JPG)

![Interacci√≥n entre Git y GitHub. Git, al ser un control de versiones distribuido, permite que todos los usuarios trabajen paralelamente sin interferir en el trabajo de los dem√°s. Luego cada usuario sincroniza su trabajo con la copia principal del proyecto ubicado en GitHub](images/conexiones.jpg)

# Instalaci√≥n

En este punto es necesario que tengas instalada la versi√≥n m√°s reciente de R (<https://cloud.r-project.org/>), RStudio (<https://www.rstudio.com/products/rstudio/download/>), Git (<https://happygitwithr.com/install-git.html>) y una cuenta en GitHub (<https://github.com/>) creada.

### üìù**Ejercicio 1.1**

1.  En el *shell*, pres√©ntate a Git ([Chapter 7: Git-Intro](https://happygitwithr.com/hello-git.html))

    *Tools* -\> *Shell*

    `git config --global user.name 'Nombre Apellido'`

    `git config --global user.email 'nombre@ejemplo.com'`

    üëÄ **Este debe ser el correo electr√≥nico asociado a tu cuenta de GitHub**

    ```{r config, eval = F} # install.packages("usethis") # library(usethis) # use_git_config(user.name = "Jane Doe", user.email = "jane@example.org")}
    ```

‚ö°¬øQu√© es el *shell*? El *shell* (o terminal) es un programa en tu ordenador cuyo trabajo es ejecutar otros programas (ver <https://happygitwithr.com/shell.html#shell>). En este curso aprenderemos a trabajar principalmente desde la l√≠nea de comandos del *shell* aunque tambi√©n veremos c√≥mo hacerlo a trav√©s de un cliente como RStudio (<https://www.rstudio.com/>), recomendable para usuarios noveles de Git (ver <https://happygitwithr.com/rstudio-git-github.html>). RStudio incorpora una pesta√±a llamada "Git" que facilita la transici√≥n entre zonas de trabajo ya que contiene funcionalidades b√°sicas de Git.

![Terminal](images/terminal.png)

![Terminal de Git](images/terminal-2.png)

![Git en RStudio](images/RStudio.JPG)

2.  Compueba que has instalado Git correctamente:

    `git --version`

    Para ver el usuario utilizado para configurar Git:

    `git config user.name`

    Para ver a qu√© cuenta de correo est√° asociado Git:

    `git config user.email`

    Para ver tanto el usuario como el correo asociado:

    `git config --global --list`

Para la resoluci√≥n de problemas durante la instalaci√≥n recomendamos mirar aqu√≠: <https://happygitwithr.com/troubleshooting.html>

3.  Genera un PAT (*Personal Access Token*) para HTTPS

    Git puede comunicarse con un servidor remoto utilizando uno de los dos protocolos: HTTPS o SSH. Nosotros utilzaremos HTTPS con *personal access token* (PAT, <https://happygitwithr.com/https-pat.html>).

```{r token, eval = F} # install.packages("usethis") # install.packages("gitcreds") # library(usethis) # library(gitcreds) # create_github_token() # generar un token # gitcreds_set() # acceder al Git credential store}
```

üëÄ Conviene describir el prop√≥sito del token en el campo *Note*, porque se pueden tener varios PATs. No podr√°s volver a ver este token, as√≠ que no cierres ni salgas de la ventana del navegador hasta que almacenes el PAT localmente. ¬°Trata este PAT como una contrase√±a!

# Repositorios y proyectos

Un repositorio es como un "contenedor" donde desarrollar un proyecto.

Para crear un repositorio en GitHub damos a "*+ New repository*". Aqu√≠ se indica el nombre, una peque√±a descripci√≥n, y si quieres que sea p√∫blico o privado. Se recomienda iniciar el repositorio con un archivo "README" (*Initialize this repository with a README*) para recoger cualquier informaci√≥n esencial para el uso del repositorio (estructura, descripci√≥n m√°s detallada del contenido, etc.).

En RStudio, creamos un nuevo proyecto y lo conectamos al repositorio: File -\> New project -\> Version control -\> Git -\> copiar el URL del repositorio que hemos creado de GitHub (est√° en la p√°gina principal de nuestro repositorio, en "*clone or download*"). Seleccionamos el directorio donde queremos guardar el proyecto y pulsamos en "*Create project*".

Si vamos al directorio seleccionado, encontraremos la carpeta conectada a Git y GitHub que hemos creado en nuestro ordenador. Podemos copiar aqu√≠ todos los archivos que nos interesan para el proyecto (datos, im√°genes, etc).

‚ö°Para m√°s informaci√≥n sobre c√≥mo clonar el repositorio en GitHub (repositorio remoto) en nuestro ordenador (repositorio local) ver <https://happygitwithr.com/rstudio-git-github.html> para hacerlo desde RStudio y @galeano2018 para hacerlo mediante la l√≠nea de comandos.

‚ö°En caso de querer conectar un antiguo proyecto de RStudio a Git y GitHub, puedes seguir los pasos que se describen aqu√≠: <https://happygitwithr.com/existing-github-first.html>.

### üìù**Ejercicio 1.2**

1.  Crea un repositorio en GitHub y con√©ctalo a un nuevo proyecto de RStudio (esto generar√° un repositorio (carpeta) en tu ordenador en la ubicaci√≥n que hayas especificado). Incluir un archivo "*.gitignore"*

2.  Crea un nuevo script de R en el directorio de trabajo (es decir, crea un script de R y gu√°rdalo dentro del repositorio que has creado)

3.  En RStudio ve a la pesta√±a Git para ver todos los documentos que han sido identificados por Git

![Lo que esperamos que hay√°is aprendido](images/git-2.png)

# Flujo de trabajo en Git y GitHub

Git es capaz de rastrear todos los archivos contenidos en un repositorio. Para comprender c√≥mo Git registra los cambios y c√≥mo podemos compartir dichos cambios con nuestros colaboradores es importante entender c√≥mo se estructura Git y c√≥mo se sincroniza con GitHub. Hay cuatro "zonas" de trabajo:

1.  **Directorio de trabajo (*working directory*):** es donde se est√° trabajando. Esta zona se sincroniza con los archivos locales del ordenador.

2.  **√Årea de preparaci√≥n (*staging area* o *Index*):** es la zona intermedia entre el directorio de trabajo y el repositorio local de Git. Es la zona de borradores. El usuario debe seleccionar los archivos que se van a registrar en la siguiente "captura" de Git.

3.  **Repositorio local (*local repository* o *HEAD*):** es donde se registran todos los cambios capturados por Git en tu ordenador.

4.  **Repositorio remoto (*remote repository*):** es donde se registran todos los cambios capturados por Git en la nube (GitHub).

![Graphical representation of the different working areas in Git and GitHub: working directory, staging area or Index, local repository or HEAD, and remote repository. Background image from Philip Brookes (https://creativecommons.org/licenses/by-nc-nd/2.0/legalcode)](images/arboles.jpg)

## ¬øC√≥mo moverse de una zona a otra?

Al principio todos los cambios realizados est√°n en amarillo porque Git no sabe que hacer con ellos. Estamos en el directorio de trabajo y puede que no nos interese guardar todos los cambios para el futuro.

Para a√±adir un cambio del directorio de trabajo al √°rea de preparaci√≥n hay que utilizar `git add`. Este comando indica a Git que se quieren incluir las actualizaciones de alg√∫n archivo en la pr√≥xima "captura" del proyecto y que Git las registre. Sin embargo, `git add` no afecta al repositorio local.

-   `git add <nombre de archivo>`: a√±ade una actualizaci√≥n de alg√∫n archivo del directorio de trabajo al √°rea de preparaci√≥n.

Para ver el estado del directorio de trabajo y del √°rea de preparaci√≥n se utiliza `git status`. Este comando permite ver qu√© archivos est√°n siendo rastreados por Git, qu√© cambios han sido a√±adidos al √°rea de preparaci√≥n (*staged*) y qu√© archivos est√°n siendo registrados por Git.

Para registrar los cambios que nos interesen hay que utilizar `git commit`. Al ejecutar `git commit` se hace una "captura" del estado del proyecto. Junto con el *commit* se a√±ade un mensaje con una peque√±a explicaci√≥n de los cambios realizados y por qu√© (p. ej. "incluyo las referencias formateadas"). Cada `git commit` tiene un SHA (*Secure Hash Algorithm*) que es un c√≥digo alfanum√©rico que identifica inequ√≠vocamente ese *commit* (p. ej. 1d21fc3c33cxxc4aeb7823400b9c7c6bc2802be1). Parece dif√≠cil de entender, pero no te preocupes, s√≥lo tienes que recordar los siete primeros d√≠gitos 1d21fc3 üòÆ(es broma). Con el SHA siempre se pueden ver los cambios que se hicieron en ese *commit* y volver a esa versi√≥n f√°cilmente.

-   `git commit -m "mensaje corto y descriptivo"`

Si se hace un `git commit` y no se escribe el mensaje se abrir√° el editor de git. El editor por defecto de Git es Vim. Para salir de Vim:

-   `ESC` y el siguiente paso depende del estado actual y de lo que quieras hacer:

    -   Si no se ha realizado ning√∫n cambio en Vim, hay que escribir `:q` y `Enter/return`

    -   Si se han realizado cambios en Vim y quieres conservarlos, hay que escribir `:wq` y `Enter/return`

    -   Si se han realizado cambios en Vim y quieres descartarlos, `:q!` y `Enter/return`

Por √∫ltimo, `git push` permite subir los cambios que hemos hecho a GitHub y quedar√°n visibles para nuestros colaboradores. B√°sicamente, `git commit` registra los cambios en el repositorio local y `git push` actualiza el repositorio remoto con los cambios y archivos asociados.

Cuando se retoma un proyecto tras horas, d√≠as o incluso meses, con `git pull` se descargan todas las actualizaciones que haya en GitHub (nuestras o de nuestros colaboradores), que se fusionar√°n (*merge*) con el √∫ltimo *commit* en nuestro repositorio local.

![Flujo de trabajo en Git y GitHub mostrando las diferentes zonas de trabajo y los comandos utilizados para la transici√≥n de una zona de trabajo a otra.](images/workflow_git_github.jpg)

### üìù**Ejercicio 1.3**

En el proyecto generado en el Ejercicio 1.2, guardad y subid los cambios realizados a GitHub (`git add` + `git commit` + `git push`)

# Propuesta de trabajo fin de curso

El trabajo se realizar√° en grupos de 2-3 personas. El objetivo es crear un proyecto rastreado por Git y alojado en GitHub donde se hayan aplicado los conocimientos aprendidos en el curso (flujo de trabajo -d√≠a 1-, trabajo en paralelo -d√≠a 2-, resoluci√≥n de problemas con Git -d√≠a 3-, etc). El proyecto consistir√° en crear un peque√±o art√≠culo de investigaci√≥n en Quarto (d√≠a 4) que contenga un objetivo, an√°lisis de unos datos (reales o inventados), un gr√°fico y un texto explicativo de los resultados.

La entrega consistir√° en una presentaci√≥n en clase (d√≠a 5) donde queremos ver el documento creado y que nos expliqu√©is las ramificaciones del proyecto, el historial de commits y otros detalles del flujo de trabajo. El d√≠a 5 habr√° tiempo para trabajar en el proyecto antes de las presentaciones.

# Algunos enlaces interesantes

**Ciencia reproducible**

-   [Ciencia reproducible: qu√©, por qu√©, c√≥mo](https://github.com/ecoinfAEET/Reproducibilidad)

**Control de versiones (Git)**

-   [Manual de referencia de Git](https://git-scm.com/docs)

-   [Software Carpentry](http://swcarpentry.github.io/git-novice/)

-   [Atlassian Bitbucket](https://www.atlassian.com/git/tutorials)

-   [Oh Shit, Git!?!](https://ohshitgit.com/)

-   [git - la gu√≠a sencilla](https://rogerdudler.github.io/git-guide/index.es.html)

-   [Pro Git](https://git-scm.com/book/es/v2)

**Integrar Git, GitHub y RStudio**

-   [Happy Git and GitHub for the useR](https://happygitwithr.com/)

**Ense√±ar y aprender con GitHub**

-   [GitHub Education para profesores e investigadores](https://docs.github.com/en/education/explore-the-benefits-of-teaching-and-learning-with-github-education/use-github-in-your-classroom-and-research/about-github-education-for-educators-and-researchers)

Aunque Git y GitHub facilitan el control de versiones de nuestros proyectos individuales, su m√°xima potencialidad se despliega al trabajar en equipo ya que facilitan el seguimiento del trabajo de todos los colaboradores y la integraci√≥n ordenada de cada parte en un producto final.

# Integraci√≥n de colaboradores en el proyecto

Para dar acceso de edici√≥n a tus colaboradores, en la p√°gina principal de nuestro proyecto en GitHub entramos en "*Settings -\> Access -\> Collaborators -\> Manage Access -\> Add people*". Los colaboradores pueden crear su copia local del proyecto de control de versiones clonando el repositorio remoto.

### üìùEjercicio 2.1

En equipos de 2 o 3 personas:

1.  El due√±o del repositorio invita al resto de integrantes del equipo a su proyecto
2.  Los colaboradores clonan el repositorio al que han sido invitados a su directorio de trabajo

# Trabajo en paralelo

## Ramificaci√≥n

Git permite crear una "rama" (*branch*) paralela al proyecto si se desea seguir una l√≠nea independiente de trabajo, bien por ser diferente de la principal (p. ej. probar un nuevo an√°lisis) o bien para desarrollar espec√≠ficamente una parte del proyecto (p. ej. trabajar s√≥lo en la escritura de los m√©todos de un art√≠culo mientras otros colaboradores trabajan en otras secciones). Las ramas permiten trabajar en el proyecto sin interferir con lo que est√°n haciendo los compa√±eros. En Git, una rama es un *commit* al que le se le da un nombre y que contiene un "enlace" (puntero o *pointer*) a un SHA espec√≠fico que es el origen de la rama. La rama *main* es la rama por defecto cuando se crea un repositorio. Las dem√°s ramas se crean con `git checkout`.

-   `git checkout -b <branchname>`: crea una nueva rama y te cambia a ella.

-   `git checkout main`: para volver a la rama principal.

![Proceso de creaci√≥n de la rama PPP y la rama monchi](images/ramas.png)

### üìùEjercicio 2.2

1.  Un integrante del equipo crea una rama en el proyecto en el que colabora

2.  Modifica la primera frase del archivo README.txt y sube los cambios al repositorio remoto

    üëÄ La primera vez que haces `git push` de una rama nueva en lugar de solamente utilizar `git push` utiliza `git push --set-upstream origin <nombre de la rama>`

3.  Vuelve a la rama main y comprueba el archivo README.txt

![](images/github_code.png)

## ¬øC√≥mo se unen distintas ramas?

Cuando el trabajo desarrollado en una rama se da por finalizado y se quiere unir a la rama principal ("*main*") hay que hacer la uni√≥n utilizando el comando `git merge`.

-   `git checkout <rama principal>`: posiciona el puntero de Git en el √∫ltimo commit de la rama principal a la que quiero unir la otra rama.

-   `git merge <rama a unir>`: fusiona los cambios hechos en las dos ramas.

Esto se puede hacer en el *shell* como acabamos de ver pero tambi√©n se puede hacer con el bot√≥n "*pull request*" en la p√°gina del proyecto en GitHub.

![Proceso de creaci√≥n y uni√≥n de ramas. Ejemplo de uni√≥n (merge) de la rama monchi a la rama main](images/merge.jpg)

Git puede encontrar conflictos al fusionar ramas que hay que arreglar manualmente. Esto ocurrir√° si en las dos ramas se han cambiado las mismas l√≠neas de un archivo. Git muestra d√≥nde est√°n los conflictos as√≠:

`<<<<<<c√≥digo del main=======c√≥digo de la rama a unir>>>>>>`

Para solucionarlo hay que escoger los cambios de la rama principal o de la rama a unir seg√∫n corresponda. Esto tambi√©n se puede hacer a trav√©s de un cliente de Git, como GitKraken (<https://www.gitkraken.com/>) o SourceTree (<https://www.sourcetreeapp.com/>). Una vez solucionados, Git permite completar el *merge* (es decir, un nuevo *commit* que contendr√° las ramas fusionadas). La mejor manera de evitar conflictos o por lo menos reducir su dificultad es realizar cambios peque√±os y sincronizar frecuentemente con GitHub.

‚ö°Si durante el merge y la resoluci√≥n de conflictos entras en p√°nico y no sabes si lo est√°s haciendo bien, siempre puedes volver al estado inicial antes de la fusi√≥n con `git merge --abort` (<https://happygitwithr.com/git-branches.html#bailing-out>).

### üìùEjercicio 2.3

1.  Un integrante del equipo modifica tambi√©n la primera frase del archivo README.txt en la rama main y sube los cambios al repositorio remoto. Esta frase hab√≠a sido previamente modificada en una rama en el ejercicio 2.2.
2.  Un integrante del equipo combina la rama del ejercicio 2.2 con la rama principal (*main*) del proyecto.
3.  Resuelve el conflicto (es decir, qu√©date con los cambios que sirvan y sube los cambios al repositorio remoto).

# Utilidades de GitHub para el trabajo colaborativo

Como ya sabemos, GitHub es un servidor de alojamiento en linea para albergar proyectos basados en Git que permite la colaboraci√≥n entre diferentes usuarios o registrar versiones para uno mismo. En la clase anterior aprendimos como crear un repositorio y conectarlo a nuestro proyecto en RStudio, y hoy hemos visto como a√±adir colaboradores al proyecto, pero GitHub tiene muchas otras funcionalidades que facilitan el trabajo colaborativo.

## Repositorios: visi√≥n general

Recordemos que un repositorio es como un "contenedor" de nuestro proyecto. GitHub facilita el acceso al contenido con todas sus diferentes versiones. En la p√°gina principal del repositorio podemos encontrar las siguientes pesta√±as:

-   **Code**: contenido del proyecto

-   **Issues**: foro del proyecto para comentar fallos, tareas pendientes, hacer peticiones a los desarrolladores, preguntar dudas, etc.

-   **Pull requests**: facilita la comparaci√≥n y fusi√≥n (*merge*) de ramas desarrolladas de forma independiente.

-   **Actions**: son peque√±as aplicaciones que realizan alguna acci√≥n cada vez que se sube un commit (p. ej. tests).

-   **Projects**: es como una hoja de c√°lculo con tareas, encargados, deadlines, status, etc. que se integra con las incidencias y solicitudes de incorporaci√≥n de cambios para ayudar a planificar las tareas y realizar el seguimiento del trabajo.

-   **Wiki**: es un espacio para documentar el proyecto (hoja de ruta, estado, documentaci√≥n detallada...).

-   **Security**: opciones de seguridad.

-   **Insights**: estad√≠sticas del proyecto.

-   **Settings**

![Repositorio en GitHub destacando algunas pesta√±as importantes](images/github_repositorio.JPG)

En la pesta√±a *Code* encontramos el contenido de nuestro proyecto:

![Repositorio en GitHub destacando informaci√≥n importante](images/github_repositorio2.JPG)

### üìùEjercicio 2.4

1.  Revisad vuestra cuenta de GitHub y comprobad los cambios que se han hecho en el proyecto compartido, tanto en la rama main como en la rama creada en el ejercicio 2.2, qui√©n los ha hecho y las lineas que se han cambiado.

## Repositorios: historial

El historial de un repositorio (*üïòXX commits*) contiene una lista de enlaces a todos los commits que se han realizado en cualquiera de las ramas. Dentro de cada *commit* se pueden ver los archivos a√±adidos o borrados en esa "captura" y las l√≠neas de c√≥digo a√±adidas (en verde) o borradas (en rojo) en cada archivo modificado. Adem√°s, en el historial, se pueden a√±adir comentarios en l√≠neas concretas de c√≥digo o comentarios generales al commit entero.

En GitHub tambi√©n se puede acceder a la historia de commits de cada archivo en concreto (*History*) y al autor de cada parte del c√≥digo (*Blame*).

El historial del proyecto y de los archivos tambi√©n es accesible a trav√©s de RStudio (üïí).

‚ö°M√°s informaci√≥n sobre como navegar en el pasado del proyecto aqu√≠: <https://happygitwithr.com/time-travel-see-past.html>

![Historial de un repositorio](images/hist.jpg)

### üìùEjercicio 2.5

1.  ¬øCuantos commits se han hecho en el archivo README.txt?

## Issues

<!--# Explicar en GitHub -->

En el √°mbito de desarrolladores de software, los *issues* cumplen la funci√≥n de rastreadores de errores. A nosotros nos interesa m√°s utilizar los issues como una lista de tareas pendientes que permite incluir tareas para acordarte de lo que tienes que hacer, pero tambi√©n se pueden usar para hacer peticiones o preguntas a los desarrolladores.

Se pueden asignar tareas o preguntas a los miembros del proyecto escribiendo "\@" antes del nombre del colaborador.

En los *issues* tambi√©n se puede referenciar a una l√≠nea concreta de c√≥digo entrando en el archivo en la pesta√±a *Code* y clickando en el n√∫mero de l√≠nea que se quiere comentar, o un *commit* entero copiando el SHA que aparece en el historial.

Una vez resuelto, el issue se cierra (*Close issue*). Se puede conectar el issue con el commit correspondiente si en el mensaje del commit a√±ades `git commit -m "Close #XX"` (p. ej., "Close #1" para cerrar el "issue" n√∫mero 1).

### üìùEjercicio 2.6

1.  Crea un script en tu repositorio y a√±ade algunas lineas o utiliza uno ya creado
2.  Publica un issue en el proyecto que incluya una lista de tareas asignando cada una a un colaborador
3.  Incluye una tarea que se refiera a una l√≠nea concreta del script

# Git ignore

Al crear un repositorio se recomienda crear un archivo "*.gitignore*". Este archivo contendr√° los nombres o extensiones de los archivos del proyecto que por defecto no queremos compartir aunque est√©n en el repositorio local (p. ej., el archivo "*.Rhistory*" que RStudio crea por defecto). Es una buena pr√°ctica ignorar archivos que no sean √∫tiles pare el resto de colaboradores as√≠ como archivos muy pesados (p. ej., una base de datos resultado de correr un script) para no subirlos y descargarlos continuamente de GitHub. Para a√±adir archivos al *gitignore* se puede utilizar el bot√≥n derecho del rat√≥n sobre el archivo en la pesta√±a Git de RStudio pero tambi√©n se puede a√±adir el nombre del archivo que desamos ignorar en el archivo "*.gitignore*" manualmente.

### üìùEjercicio 2.7

1.  **Un miembro** del equipo descarga en su directorio de trabajo la √∫ltima versi√≥n del proyecto compartido si a√∫n no lo tiene (`git pull`).
2.  Crea un nuevo archivo en la carpeta en su ordenador.
3.  A√±ade el nombre del nuevo archivo a .gitignore.
4.  Sube todo al repositorio remoto y comprueba que archivos se han subido (`git add .` + `git commit -m "XX"` + `git push`).

üëÄSi has hecho un commit por error con archivos que quer√≠as ignorar, todav√≠a se puede arreglar. Primero tienes que decir a Git que deje de rastrear el archivo con `git rm --cached <archivo>`, despu√©s a√±adelo a *.gitignore* y haz un nuevo commit. El archivo no desaparecer√° de tu ordenador pero con `git pull` se eliminar√° del repositorio remoto.

# GitHub: la red social

GitHub no es s√≥lo un repositorio remoto donde almacenar diferentes versiones de tu trabajo o desarrollar proyectos colaborativos, si no que tambi√©n es una red de encuentro para programadores. Como en otras redes puedes cotillear perfiles, seguir a ciertas personas, tener seguidores, guardar proyectos que te gustan...

Con el buscador (üîç) puedes buscar aquellos contenidos que te interesan. La b√∫squeda est√° organizada por categor√≠as (*Repositories, Commits, Issues, Users*...) lo que facilita encontrar lo que buscas. Para seguir a un usuario tienes la opci√≥n *Follow*. Pulsando *Star*‚≠ê puedes guardar un enlace a cualquier repositorio en tu cuenta de GitHub y con *Fork* estar√≠as guardando una copia con la que puedes interaccionar. Con *Watch*üëÅÔ∏è puedes hacer un seguimiento de un repositorio. *Download* te permite guardar una copia de cualquier repositorio p√∫blico en tu ordenador.

## Fork

GitHub contiene multitud de proyectos p√∫blicos que todos los usuarios pueden clonar y desarrollar independientemente. Al hacer una clonaci√≥n, se crea una ramificaci√≥n o copia del proyecto ("*fork*") que pasa a formar parte de tu cuenta de usuario en GitHub. En caso de que desees unir los cambios realizados al proyecto original, deber√°s solicitarlo (="*pull request*"). El due√±o del proyecto decide si acepta o no los cambios que propones.

# Flujo de trabajo: repaso

Hay cuatro zonas en el flujo de trabajo de Git y GitHub: **directorio de trabajo, √°rea de preparaci√≥n, repositorio local** y **repositorio remoto**. Con `git pull` se descargan todas las actualizaciones del repositorio remoto al repositorio local y al directorio de trabajo. Con `git add` se a√±aden los cambios en el directorio de trabajo al √°rea de preparaci√≥n. Para registrar los cambios en el repositorio local hay que utilizar `git commit` y, despu√©s, para subirlos al repositorio remoto `git push`.

‚ö°Usar `git commit` es para el proyecto como usar anclajes cuando estamos escalando una pared de roca. Desarrollar un script sin commits es como escalar sin asegurarse: puedes avanzar mucho m√°s r√°pido a corto plazo, pero a largo plazo las probabilidades de fallo catastr√≥fico son altas. Por otro lado, hacer muchos commits va a ralentizar tu progreso. Lo mejor: usar m√°s commits cuando est√°s en un territorio incierto o peligroso.

![Lineas de trabajo (cuerdas) aseguradas con varios commits (anclajes)](images/climbing.png)

### üìùEjercicio 3.1

1.  Uno por uno y secuencialmente cada integrante del equipo (a) descarga la copia centralizada del proyecto compartido, (b) hace un cambio en alg√∫n archivo y (c) lo sube de nuevo a GitHub.

2.  Comprobad que el historial del proyecto tiene dos o tres nuevos commits, seg√∫n el n√∫mero de personas en el equipo

# Soluci√≥n de errores comunes en el flujo de trabajo

Git y GitHub permiten resolver problemas comunes en el trabajo colaborativo pero tambi√©n pueden causarnos bastantes quebraderos de cabeza. Es com√∫n que al intentar hacer `git push` no te deje porque, o bien, alguno de tus colaboradores ya lo ha hecho antes (¬°y sin avisar!) y no tienes todos los cambios remotos integrados en tu repositorio local, o bien, t√∫ te has olvidado de hacer `git pull` al empezar a trabajar y has guardado cambios importantes en el directorio de trabajo sin tener actualizado el proyecto con la copia remota. En este ultimo caso **haz un commit** con los cambios y antes de desesperar echa un ojo a este apartado.

Como resultado, en ambos casos, el historial del repositorio remoto (A -\> B -\> C) y el local (A -\> B -\> D) habr√°n divergido y no se pueden juntar. Hay varias soluciones para este problema (<https://happygitwithr.com/pull-tricky.html>) y aqu√≠ hemos recogido una de ellas en la que el objetivo final es tener A -\> B -\> C+D. La soluci√≥n consiste en usar `git pull`. Como sabemos, este comando descarga los cambios y el historial del repositorio remoto y los incorpora en el repositorio local. Internamente `git pull` est√° compuesto por dos comandos:

-   `git fetch`: "trae" los cambios del repositorio remoto al local, pero no cambia los archivos locales (directorio de trabajo).

-   `git merge`: fusiona el nuevo historial y los cambios con lo que hab√≠a en el repositorio local. La idea es la misma que al fusionar ramas.

Al hacer `git pull` cuando los historiales no coinciden pueden ocurrir dos cosas:

1.  No hay conflictos al fusionar ambos commits: ¬°solucionado!

2.  Aparecen conflictos en `git merge` porque C y D tienen cambios en las mismas partes de los mismos archivos. En este caso, hay que resolver los conflictos como vimos en la fusi√≥n de ramas, es decir, buscar los puntos de conflicto (`<<<<<<c√≥digo del main=======c√≥digo de la rama a unir>>>>>>)`, elegir la versi√≥n que corresponda, guardar el archivo y hacer de nuevo `git add`, `git commit` y `git push`.

‚ö°¬øC√≥mo prevenir que Git rechace `git push`? (<https://happygitwithr.com/push-rejected.html>) 1. Haz `git push` de tu trabajo con frecuencia. 2. Haz `git pull` del trabajo de otros tan pronto como te des cuenta que el repositorio remoto se ha actualizado. 3. ¬°Comunicate con tus colaboradores! 4. Usa ramas en lugar de trabajar en *main*.

### üìùEjercicio 3.2

Vamos a crear un conflicto en nuestro repositorio para despu√©s solucionarlo.

1.  Un miembro del equipo cambia la primera l√≠nea del archivo README.txt y lo sube a GitHub

2.  **Sin hacer `git pull`**, un segundo miembro del equipo cambia la misma l√≠nea del mismo archivo y lo intenta despu√©s subir a GitHub. ¬øQu√© error obtenemos? ¬øC√≥mo lo solucionamos?

3.  La segunda persona ejecuta `git pull` y entre todos resolveis el conflicto. ¬øC√≥mo es el historial del archivo ahora?

# Comandos avanzados de Git

## La he liado ¬øc√≥mo deshago los cambios?

Cuando hago un cambio que no quiero ¬øc√≥mo lo puedo resolver? Hay m√∫ltiples opciones pero aqu√≠ detallamos tres: *restore*, *reset* y *revert*. Restore se usa cuando no has llegado a hacer un commit con los cambios que quieres a√±adir y reset/revert cuando si has hecho un commit con los cambios.

-   `git restore`: deshace un `git add` y/o los cambios del directorio de trabajo.

    -   `git restore <nombre de archivo>`: descarta los cambios en un archivo al estado del √∫ltimo commit. ‚ö†Ô∏èEsta opci√≥n es peligrosa ya que borra los cambios no commitidos de tu directorio de trabajo.

    -   `git restore --staged <nombre de archivo>`: eliminar√° el archivo del √°rea de preparaci√≥n pero mantiene los cambios del directorio de trabajo.

-   `git reset`: deshace un `git commit` y/o un `git add` y/o los cambios del directorio de trabajo.

    -   `git reset --mixed HEAD~1`: deshace el add y el commit pero no los cambios realizados en el directorio de trabajo. Es equivalente a `git reset` (es decir, la opci√≥n por defecto). El HEAD\~1 significa el commit anterior al HEAD. Puedes ir un commit hacia atr√°s, dos, etc. Tambi√©n se puede utilizar el SHA en lugar del HEAD`~X` para ir a un commit espec√≠fico.

    -   `git reset --hard HEAD~1`: deshace el add, el commit y todos los cambios realizados en el directorio de trabajo. ‚ö†Ô∏è Esta es la opci√≥n m√°s PELIGROSA. Ten en cuenta que borra los cambios no commitidos de tu directorio de trabajo y apunta tu rama al commit especificado. Recomendamos ejecutar primero `git status` y ver si hay cambios no commitidos.

    -   `git reset --soft HEAD~1`: deshace el √∫ltimo commit pero no el add ni los cambios realizados en el directorio de trabajo.

![Diferencias entre `git restore` y distintos tipos de `git reset`](images/git_restore_reset.png)

-   `git revert HEAD`: es la opci√≥n segura de `git reset` para deshacer un commit ya que no resetea un proyecto a su estado anterior eliminando todos los commits posteriores (es decir, no elimina el historial de commits). Recomendamos usar `git reset` s√≥lo en ramas que no hayan sido compartidas todav√≠a (es decir, que no hayan sido commitidas a un repositorio remoto que otros est√©n usando). Resetear es cambiar el historial sin dejar rastro. Esto es siempre una mala pr√°ctica y puede causar problemas al resto de colaboradores. Si queremos deshacer los cambios en las ramas que se comparten con otros, recomendamos utilizar el comando `git revert`. Con `git revert` quedar√° constancia de que se ha deshecho un cambio.

![Diferencias entre `git revert` y `git reset`](images/revert_reset.png)

### üìùEjercicio 3.3

El objetivo de este ejercicio es que veais las diferencias entre los distintos tipos de `git reset`. Para ello, tendr√©is que utilizar `git status` para ver el estado de git despu√©s de cada `git reset`.

Cada integrante del equipo independientemente:

1.  Realiza algunos cambios en el repositorio y realiza un commit de los cambios y prueba hacer `git reset --soft HEAD~1`
2.  Realiza otro commit y prueba hacer `git reset --mixed HEAD~1`
3.  Realiza un √∫ltimo commit y prueba hacer `git reset --hard HEAD~1`

## Otros comandos √∫tiles

**Para facilitar el flujo de trabajo**:

-   `git add .`: registra todos los cambios a la vez

-   `git rm --cached filename`: elimina un archivo del √°rea de preparaci√≥n. Muy √∫til si has a√±adido un archivo de 10GB que no lo quieres compartir cada vez ‚ö†Ô∏è

-   `git stash`: cuando no quieres hacer un commit del trabajo a medio hacer o no est√°s seguro si lo quieres conservar pero quieres volver a este punto m√°s tarde. Crea un commit fuera de la linea principal de trabajo

-   `git stash apply`: recupera cualquier stash que has guardado

**Para obtener informaci√≥n de Git**:

-   `git status`: muestra la rama en la que estamos y los cambios hechos y a√±adidos desde el √∫ltimo commit.

-   `git diff`: muestra los cambios no a√±adidos con `git add`. Tambi√©n se puede usar para ver diferencias entre ramas `git diff <branchname1>‚Ä¶<branchname2>`.

-   `git log`: muestra el historial de commit. Con `git log -n X` muestra s√≥lo un n√∫mero X de commits.

-   `git branch -a`: muestra todas las ramas locales y remotas. Tambi√©n te indica en qu√© rama te encuentras

-   `git stash list`: ver los stash que has guardado

-   `gitk`: para visualizar la interfaz gr√°fica de Git.

**Para mantener el orden en tu repositorio**:

-   `git branch -d <branchname>`: elimina la rama llamada "branchname" de tu pc

-   `git push origin --delete <branchname>`: elimina la rama remota llamada "branchname" (por ejemplo, desde GitHub). Ten en cuenta que la rama local y la remota no tienen nada que ver entre s√≠, por lo que deben eliminarse por separado

-   `git commit --amend -m "message"`: cambiar el mensaje del √∫ltimo commit

-   `git clean -f`: borra (‚ö†Ô∏èojo) archivos que no est√°n siendo monitorizados por Git. Es √∫til para eliminar todos los productos creados al ejecutar alg√∫n script

-   `git push --force`: se utiliza para sobreescribir la historia de la rama en la que est√°s trabajando. En este sentido, por ejemplo, se puede utilizar despu√©s de `git reset --hard` . ‚ö†Ô∏è‚ö†Ô∏èEsta opci√≥n es DOBLEMENTE PELIGROSA. No solo borras los cambios no commitidos si no que modificas la historia de un archivo. Si alg√∫n colaborador ya he descargado el archivo con su historia anterior, tendr√° problemas cuando quiera integrar sus cambios de nuevo. ¬°Utilizar s√≥lo en casos extremos! (p. ej. publico sin querer mis claves de acceso a alguna base de datos)

**Para integrar versiones anteriores**:

-   `git checkout HEAD~X`: para inspeccionar una versi√≥n (X) antigua del proyecto. Recomendamos crear una rama primero si se quiere a√±adir commits a partir de este punto temporal.

-   `git cherry-pick SHA`: permite coger cualquier commit de una rama y fusionarlo con otra. Es √∫til si, por ejemplo, has hecho un commit en la rama equivocada y lo quieres mover a la correcta. Sin embargo, en general, un merge tradicional suele ser la mejor pr√°ctica (<https://www.atlassian.com/git/tutorials/cherry-pick>).

![`git cherry-pick` por \@girlie_mac](images/git_cherry_pick.jpeg)

### üìùEjercicio 3.4

¬øQu√© comando o comandos utilizar√≠as si...

1.  ...llevas mucho sin trabajar en un proyecto y no te acuerdas de los √∫ltimos pasos que se hab√≠an dado?
2.  ...haces un mont√≥n de pruebas para un an√°lisis y no las quieres borrar pero tampoco dejar todas en la l√≠nea principal del proyecto?
3.  ...has creado 10 plots con tus datos (archivos nuevos) pero no los quieres compartir porque se pueden crear con el script que vas a subir a GitHub?
4.  ...un colaborador ha realizado un commit y un push mientras t√∫ estabas trabajando en la misma rama?

------------------------------------------------------------------------

<details>

<summary>Session Info</summary>

```{r session_info}
Sys.time()
sessionInfo()
```

</details>
