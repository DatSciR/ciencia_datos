---
title: | 
  | Organizaci√≥n de datos y bases de programaci√≥n funcional
subtitle: "Curso: Programaci√≥n y an√°lisis estad√≠stico en R. CADIC, Ushuaia, Argentina"
author: 
  - name: Ver√≥nica Cruz-Alonso 
    roles: "Profesora y autora del material"
  - name: Julen Astigarraga
    roles: "Autor del material"
date: today
date-format: "DD/MM/YYYY"
toc: true
toc-depth: 4
toc-title: "√çndice"
format:
  html:
    link-external-newwindow: true
    # css: styles.css
  gfm: default
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
---

## Objetivos del d√≠a 2

-   Entender la filosof√≠a de {tidyverse}.

-   Aprender funciones b√°sicas que nos permitan importar, explorar, limpiar, transformar y manejar datos.

-   Aprender a escribir funciones.

-   Entender la programaci√≥n iterativa mediante el paquete {purrr} de {tidyverse}.

## Introducci√≥n a tidyverse

[*Tidyverse*](https://www.tidyverse.org/) es una colecci√≥n de paquetes (meta-paquete) de R. El n√∫cleo contiene ocho paquetes principales (`readr`, `tibble`, `dplyr`, `tidyr`, `stringr`, `forcats`, `ggplot2` y `purrr`), que comparten el dise√±o, la gram√°tica y la estructura de los datos que necesitan. En el centro de la filosof√≠a de tidyverse se encuentra la noci√≥n de ‚Äúdatos ordenados‚Äù (*tidy data*). Hadley Wickham (principal desarrollador de *tidyverse*) los define como ‚Äúf√°ciles de manipular, modelar y visualizar, y que tienen una estructura espec√≠fica: cada variable es una columna, cada observaci√≥n es una fila y cada valor es una celda‚Äù. *Tidyverse* puede considerarse un dialecto del lenguaje de programaci√≥n R que discretiza funciones amplias de R base (p. ej. `merge`) en diversas funciones espec√≠ficas (p. ej. `left_join`, `right_join`).

Los [tres principios b√°sicos](https://design.tidyverse.org/unifying.html) de este meta-paquete son:

-   **Centrado en humanos**: tiene un dise√±o intuitivo que facilita su uso y accesibilidad para el usuario, ya que est√° dise√±ado espec√≠ficamente para respaldar las actividades de un analista de datos humano.

-   **Consistencia**: todos los paquetes est√°n dise√±ados para trabajar con datos ordenados (*tidy data*), y las funciones de los paquetes tienen una nomenclatura com√∫n y congruente. Esto permite que un usuario que aprende sobre una funci√≥n o paquete pueda aplicar ese conocimiento a otros, facilitando as√≠ la tarea de recordar y deducir c√≥digo.

-   **Componiblidad**: permite al usuario resolver problemas complejos dividi√©ndolos en peque√±as partes, que pueden combinarse utilizando el operador *pipe*, ya sea el del paquete `magrittr` (`%>%`) o el creado recientemente en R base (`|>`).

üí°Los dos operador *pipe* tienen peque√±as [diferencias](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/) pero en general el comportamiento es el mismo.

üí°Para m√°s informaci√≥n sobre *tidyverse* y las diferencias con R base te recomendamos leer [*Tidyverse: colecci√≥n de paquetes de R para la ciencia de datos*](https://revistaecosistemas.net/index.php/ecosistemas/article/view/2745).

```{r pipe}
#| warning: false

library(tidyverse)

d <- c("hi", "hola", "hola", "hi")

length(unique(d))  
d |> unique() |> length() # Ctrl + Shift + M para poner un pipe
```

En este curso realizaremos las distintas tareas que forman parte de la ciencia de datos utilizando *tidyverse*, aunque tambi√©n se podr√≠an llevar a cabo con R base.

## Importar datos y renombrar variables

### [Read_delim](https://readr.tidyverse.org/reference/read_delim.html): leer datos desde fuera de R

```{r read}
#| warning: false

taludes <- read_delim(file = "taludes.csv", delim = ",")

taludes

taludes_bien <- read_delim(file = "taludes.csv", 
  delim = ",", col_types = list(Luz = "f", Agua = "f"))

taludes_bien
View(taludes_bien)
summary(taludes_bien)
glimpse(taludes_bien)
```

### [Rename](https://dplyr.tidyverse.org/reference/rename.html): cambiar nombres de variables (columnas)

```{r rename}
#| warning: false  

names(taludes_bien)

taludes_bien <- taludes_bien |>    
  rename(biomasa = Biomasa, # nombre nuevo = nombre viejo          
         nivel_luz = Luz, 
         agua_estival = Agua)
```

üìù Ajustar sangr√≠a de c√≥digo: Ctrl + i; Reformatear c√≥digo: Ctrl + Shift + a

üìù Usar espacios antes y despu√©s de `=` y despu√©s de `,` hace mucho m√°s f√°cil identificar los argumentos de la funci√≥n y, en general, todos los componentes.

```{r espacios}

set.seed(123) 
mean(rnorm(10, mean = 50, sd = 25) / 12, trim = 0.2)  

set.seed(123) 
mean(rnorm(10,mean=50,sd=25)/12,trim=0.2)
```

## Funciones b√°sicas de filtrado y selecci√≥n

### [Slice](https://dplyr.tidyverse.org/reference/slice.html): filtrar filas seg√∫n el √≠ndice num√©rico

```{r slice}
#| warning: false

taludes_bien |> 
  slice(1) # shortcut para el pipe: CTRL + SHIFT + M 

taludes_bien |>
  slice(1, 5)

taludes_bien |> 
  slice(1:6)

taludes_bien |>
  slice(-c(1:5))

```

### [Arrange](https://dplyr.tidyverse.org/reference/arrange.html): ordenar filas por los valores de una o m√°s variables (columnas)

```{r arrange}
#| warning: false

taludes_bien |>
  arrange(biomasa)

taludes_bien |> 
  arrange(desc(biomasa))

```

### [Filter](https://dplyr.tidyverse.org/reference/filter.html): filtrar filas utilizando condiciones

Se necesita un vector de filtrado que contenga valores l√≥gicos (TRUE/FALSE).

```{r filter}
#| warning: false

taludes_bien |>
  filter(nivel_luz == "Nivel 1") # filtrar por filas que cumplen un patr√≥n 

taludes_bien |>
  filter(nivel_luz == "Nivel 1" & biomasa > 4) # combinar criterios: AND

taludes_bien |>
  filter(nivel_luz == "Nivel 1" | biomasa > 5) # combinar criterios: OR

taludes_bien |>
  filter(nivel_luz %in% c("Nivel 1", "Nivel 3")) # combinar criterios: %in% 
```

#### Ejercicio

-   Lee el data.frame "Macrobenthos.txt". Pista: el delimitador entre datos es el tabulador ("\t").

üí°"Macrobenthos.txt" es una base de datos sobre la abundancia de distintos grupos taxon√≥micos de macroinvertebrados marinos ([Zuur et al. 2009](https://link.springer.com/book/10.1007/978-0-387-93837-0)).

-   Crea un subset de datos que contenga las filas de la 1 a la 10 y de la 390 a la 400.

-   Crea un subset que NO contenga el Taxon n√∫mero 1. Pista: revisa los [operadores de R](https://bookdown.org/jboscomendoza/r-principiantes4/operadores-relacionales.html).

-   Crea un subset con las observaciones del Taxon 2 donde se haya registrado una abundancia mayor de 50 o menor o igual a 5. Pista: necesitar√°s par√©ntesis para filtrar.

-   ¬øCu√°ntas filas han quedado?

### [Select](https://dplyr.tidyverse.org/reference/select.html): seleccionar columnas utilizando condiciones

Se necesita un vector de selecci√≥n que contenga valores l√≥gicos (TRUE/FALSE).

```{r select}
#| warning: false

taludes_bien |>
  select(biomasa, agua_estival)

?select # operators y selection helpers

taludes_bien |>
  select(contains("a"))

# se pueden utilizar todo tipo de patrones de texto: https://rstudio.github.io/cheatsheets/strings.pdf

taludes_bien |>
  select(nivel_luz, everything()) # se puede usar para reordenar variables

```

#### Ejercicio

-   Con el data.frame "Macrobenthos.txt", crea un nuevo data.frame que contenga las variables relacionadas con el medio (de *organic matter* a *temperature*). Pista: mira la ayuda de select para ahorrar caracteres.

-   Crea un nuevo objeto con el taxon al principio y que incluya las dem√°s columnas excepto el esfuerzo de muestreo (*effort*).

## Transformar los datos y calcular nuevas variables

### [Mutate](https://dplyr.tidyverse.org/reference/mutate.html): crear, modificar o eliminar columnas

```{r mutate}
#| warning: false

taludes_bien |>
  mutate(
    # definir una variable desde cero
    ID = 1:nrow(taludes_bien), 
    supervivencia = as.factor(sample(
      c(0, 1),
      size = nrow(taludes_bien),
      prob = c(0.4, 0.6),
      replace = TRUE
    )),
    # utilizar una variable para calcular otra
    carbono = biomasa * rnorm(
      n = nrow(taludes_bien),
      mean = 0.4,
      sd = 0.2
    )
  ) |> 
  select(ID, everything())

taludes_bien |>
  mutate(
    # sobreescribir una variable. En concreto fct_recode 
    # sirve para redefinir los niveles de un factor
    agua_estival = fct_recode(
      agua_estival, sequia = "Sequia estival", lluvia = "Lluvia estival"),
    nivel_luz = fct_recode(
      nivel_luz,
      `1` = "Nivel 1",
      `2` = "Nivel 2",
      `3` = "Nivel 3"
    )
  )

taludes_bien |>
  mutate(
    # utilizar varias variables para calcular otra nueva
    estres = case_when(
      # "Si el nivel de luz es 1 y hay sequia, el estr√©s ser√° alto"
      nivel_luz == 1 & agua_estival == "sequia" ~ "alto",
      nivel_luz == 3 & agua_estival == "lluvia" ~ "bajo",
      TRUE ~ "intermedio"
    )
  )

# repetimos todo lo anterior concatenando todo el proceso:

taludes_trans <- taludes_bien |> 
  mutate(
  ID = 1:nrow(taludes_bien),
  supervivencia = as.factor(sample(
    c(0, 1),
    size = nrow(taludes_bien),
    prob = c(0.4, 0.6),
    replace = TRUE
  )),
  carbono = biomasa * rnorm(
    n = nrow(taludes_bien),
    mean = 0.4,
    sd = 0.2
  )
) |>
  mutate(
    agua_estival = fct_recode(agua_estival, sequia = "Sequia estival", lluvia = "Lluvia estival"),
    nivel_luz = fct_recode(
      nivel_luz,
      `1` = "Nivel 1",
      `2` = "Nivel 2",
      `3` = "Nivel 3"
    )
  ) |>
  mutate(
    estres = case_when(
      nivel_luz == 1 &
        agua_estival == "sequia" ~ "alto",
      nivel_luz == 3 &
        agua_estival == "lluvia" ~ "bajo",
      TRUE ~ "intermedio"
    )
  )

```

#### Ejercicio

-   Con el data.frame macrobenthos genera una nueva columna con la relaci√≥n entre la turbidez del agua y la materia org√°nica.

### [Summarise](https://dplyr.tidyverse.org/reference/summarise.html) y [group by](https://dplyr.tidyverse.org/reference/group_by.html): generar un nuevo `data.frame` resumiendo cada grupo a una fila

```{r summarise}
#| warning: false

taludes_trans |> 
  summarise(c_min = min(carbono),
            c_max = max(carbono))

```

```{r group_by}
#| warning: false

taludes_trans |>
  group_by(estres) |>  
  summarise(biomasa_min = min(biomasa),
            biomasa_mean = mean(biomasa),
            biomasa_max = max(biomasa))

```

#### Ejercicio

-   Con el data.frame macrobenthos, cuenta el n√∫mero de casos que hay en cada periodo de muestreo.

-   Cuenta el n√∫mero de casos distintos que hay de esfuerzo de muestreo.

-   Calcula la media de la turbidez para cada tax√≥n.

### [Pivot](https://tidyr.tidyverse.org/reference/pivot_longer.html): transformar datos a formato ancho a largo y viceversa

![La variable a√±o est√° dividida en dos columnas y cada fila representa dos observaciones no una. Extraido de [R for Data Science](https://r4ds.had.co.nz/tidy-data.html).](images/tidy_pivot_longer.png)

```{r pivot}
#| warning: false

stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)

stocks |> 
  pivot_wider(names_from = year, values_from = return) 

stocks |> 
  pivot_wider(names_from = year, values_from = return) |> 
  pivot_longer(cols = `2015`:`2016`, names_to = "year", values_to = "return")
```

## [Joins](https://dplyr.tidyverse.org/reference/mutate-joins.html): unir data.frames

`*_join()` a√±ade columnas de `y` (segundo data.frame) a `x` (primer data.frame), haciendo coincidir las observaciones en funci√≥n de la variable com√∫n.

![Tipos de uniones. Extraido del [Cheat sheet de dplyr](https://nyu-cdsc.github.io/learningr/assets/data-transformation.pdf).](images/clipboard-920719998.png){width="250"}

```{r joins}
#| warning: false

# join: left, right, full, inner

set.seed(123)

bloques <- tibble(ID = 1:nrow(taludes_trans), 
  bloque = sample(x = 1:2, size = nrow(taludes_trans), replace = TRUE))

taludes_trans <- taludes_trans |> 
  left_join(bloques, by = "ID") |> 
  select(ID, bloque, everything())

```

## [Write_delim](https://readr.tidyverse.org/reference/write_delim.html): guardar datos

```{r export}
#| warning: false

write_delim(taludes_trans, file = "taludes_trans.csv", delim = ";")

# en file hay que especificar el directorio donde queremos que se guarde. Si no, se guardar√° en el directorio de trabajo (getwd())
```

## Enlaces de inter√©s sobre manipulaci√≥n de datos

-   [Cheat sheet de dplyr](https://nyu-cdsc.github.io/learningr/assets/data-transformation.pdf)

-   [R for data Science (Data transformation)](https://r4ds.had.co.nz/transform.html)

-   [P√°gina web de *tidyverse*](https://www.tidyverse.org)

-   [Style guide](http://adv-r.had.co.nz/Style.html)

## Introducci√≥n a la programaci√≥n funcional

La creciente disponibilidad de datos y de versatilidad de los programas de an√°lisis han provocado el incremento en la cantidad y complejidad de los an√°lisis que realizamos. Esto hace cada vez m√°s necesaria la eficiencia en el proceso de gesti√≥n y an√°lisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programaci√≥n basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el c√≥digo.

Como las funciones en R son objetos, es posible llamarlas a trav√©s de otras funciones e iterar este proceso, lo que constituye la base de la programaci√≥n funcional y convierte a R en una herramienta muy poderosa. Las iteraciones sirven para realizar la misma acci√≥n a m√∫ltiples entradas.

```{r ejemplo_importancia_PF}
#| warning: false  

# install.packages("palmerpenguins")
library(palmerpenguins)

df <- penguins |>
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

df_rescaled1 <- df |>
  mutate(
    bill_length_mm = (bill_length_mm - min(bill_length_mm, na.rm = TRUE)) / (
      max(bill_length_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)
    ),
    bill_depth_mm = (bill_depth_mm - min(bill_depth_mm, na.rm = TRUE)) / (
      max(bill_depth_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)
    ),
    flipper_length_mm = (flipper_length_mm - min(flipper_length_mm, na.rm = TRUE)) / (
      max(flipper_length_mm, na.rm = TRUE) - min(flipper_length_mm, na.rm = TRUE)
    ),
    body_mass_g = (body_mass_g - min(body_mass_g, na.rm = TRUE)) / (max(body_mass_g, na.rm = TRUE) - min(body_mass_g, na.rm = TRUE))
  )

View(df_rescaled1)

rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)      
  (x - rng[1]) / (rng[2] - rng[1])
}

df_rescaled2 <- df |>
  mutate(
    bill_length_mm = rescale01(bill_length_mm),
    bill_depth_mm = rescale01(bill_depth_mm),
    flipper_length_mm = rescale01(flipper_length_mm),
    body_mass_g = rescale01(body_mass_g)
  )

View(df_rescaled2)

df_rescaled3 <- lapply(df, rescale01)

View(df_rescaled3)

```

Las principales **ventajas de la programaci√≥n funcional** (uso de funciones e iteraciones) son:

-   Facilidad para ver la intenci√≥n del c√≥digo y, por tanto, mejorar la **comprensi√≥n** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El c√≥digo queda m√°s ordenado.
-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.
-   **Disminuye la probabilidad de error**.

### ¬øCu√°ndo hay que usar una funci√≥n?

Se recomienda seguir el principio "do not repeat yourself" ([DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.)): cada unidad de conocimiento o informaci√≥n debe tener una representaci√≥n √∫nica, inequ√≠voca y autoritativa en un sistema.

Escribir una funci√≥n ya merece la pena cuando has copiado y pegado m√°s de dos veces lo mismo (don't be WET! - Write Everything Twice). Cuantas m√°s veces est√© repetido un c√≥digo, en m√°s sitios necesitar√°s actualizarlo si hay algun cambio y m√°s aumenta la probabilidad de error.

## Teor√≠a sobre funciones en R

Seg√∫n el tipo de output generado (√∫ltima expresi√≥n ejecutada dentro de la funci√≥n) hay dos tipos de funciones:

-   Las **funciones de transformaci√≥n** transforman el objeto que entra en la funci√≥n (primer argumento) y devuelven otro objeto o el anterior modificado. Los funcionales son tipos especiales de funciones de transformaci√≥n.

    ![](images/function.png)

-   Las **funciones secundarias** (*side-effect functions*) tienen efectos colaterales y ejecutan una acci√≥n, como guardar un archivo o dibujar un plot. Algunos ejemplos de funciones secundarias que se usan comunmente son: `library()`, `setwd()`, `plot()`, `write_delim()`... Estas funciones retornan *de forma invisible* el primer argumento, que no se guarda, pero puede ser usado en un *pipeline*.

En general, sint√°cticamente, las funciones tienen tres componentes:

-   Funci√≥n `function()`
-   Argumentos: lista de entradas.
-   Cuerpo: trozo de c√≥digo que sigue a `function()`, tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {
  paste(x, y, sep = "_")
}

nombre1_v2 <- function(x, y) paste(x, y, sep = "_")

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")

nombre1_v1("Vero", "Cruz")
nombre1_v2("Vero", "Cruz")
nombre1_v3("Vero", "Cruz")
```

üìù Si la funci√≥n tiene m√°s de dos lineas es mejor usar llaves siempre para que quede bien delimitada. La llave de apertura nunca debe ir sola pero s√≠ la de cierre (excepto con *else*). Las sangr√≠as tambi√©n ayudan mucho a entender la jerarqu√≠a del c√≥digo dentro de las funciones.

En general las funciones tienen un nombre que se ejecuta cuando se necesita como hemos visto hasta ahora, pero esto no es obligatorio. Algunos paquetes como {purrr} o las funciones de la familia `apply` permiten el uso de **funciones an√≥nimas** para iterar.

```{r funciones_anonimas}

map(penguins, function(x) length(unique(x)))  

penguins |>    
  map(function(x) length(unique(x)))
```

üìù Mejor reservar el uso de funciones an√≥nimas para funciones cortas y simples. Si la funci√≥n es larga, ocupa varias l√≠neas o tenemos que usarla con frecuencia mejor darle un nombre.

## C√≥mo escribir funciones {#sec-writefun}

#### Ejercicio

Genera tu primera funci√≥n que divida un valor siempre entre 100.

üí°Atajo para escribir funciones: escribir la palabra fun + tabulador

Imaginad que para un set de datos quisieramos hacer un gr√°fico de distribuci√≥n de cada variable num√©rica, en funci√≥n de otra variable categ√≥rica que nos interese especialmente, para ver c√≥mo se distribuye.

```{r codigo_repetido_avanzado}
#| warning: false  

penguins_num <- penguins |>
  select(species, sex, where(is.numeric))  # nos interesan las diferencias entre especie y sexo

ggplot(penguins_num, aes(x = species, y = bill_length_mm, color = sex)) +     geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = bill_depth_mm, color = sex)) +   geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = flipper_length_mm, color = sex)) +   geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()  # etc
```

Hemos copiado un c√≥digo m√°s de dos veces para realizar una misma acci√≥n (es decir, un gr√°fico para ver como se distribuye una variable en funci√≥n de otras dos que se mantienen constantes) as√≠ que hay que considerar la posibilidad de que estemos necesitando una funci√≥n. A continuaci√≥n vamos a seguir unos **sencillos pasos para transformar cualquier c√≥digo repetido en funci√≥n**.

1.  Analizar el c√≥digo: ¬øcu√°les son las partes replicadas? ¬øcuantas entradas tenemos? ¬øcu√°les var√≠an y cu√°les no?

2.  Simplificar y reanalizar duplicaciones

```{r funcion_simplificar}
#| warning: false  

var <- penguins_num$bill_length_mm  

ggplot(penguins_num, aes(x = species, y = var, color = sex)) +   
  geom_point(position = position_jitterdodge(), alpha = 0.3) +   
  geom_boxplot(alpha = 0.5) +   
  scale_color_manual(values = c("turquoise", "goldenrod1")) +   
  theme_light()
```

```{r funcion_simplificar_2}
#| warning: false 
#| error: true  

var <- body_mass_g 
var <- "body_mass_g"  

ggplot(penguins_num, aes(x = species, y = var, color = sex)) +   
  geom_point(position = position_jitterdodge(), alpha = 0.3) +   
  geom_boxplot(alpha = 0.5) +   
  scale_color_manual(values = c("turquoise", "goldenrod1")) +   
  theme_light() +   
  ylab(var) # grafico erroneo  

ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) +   
  geom_point(position = position_jitterdodge(), alpha = 0.3) +   
  geom_boxplot(alpha = 0.5) +   
  scale_color_manual(values = c("turquoise", "goldenrod1")) +   
  theme_light() +   
  ylab(var) # grafico correcto
```

üëÄ La funci√≥n `ggplot` necesita argumentos (data-variable) que est√©n dentro del `data.frame` que va a representar. Para poder generalizar la funci√≥n hemos guardado el nombre de la variable en un objeto (tipo `character`), pero `ggplot` no acepta `characters`. Por ello necesitamos utilizar una funci√≥n intermedia que s√≠ los acepte. Para resolver problemas comunes de programaci√≥n funcional derivados de la *non-standard evaluation* de *tidyverse* [mira este enlace](https://dplyr.tidyverse.org/articles/programming.html#introduction).

3.  Elegir un nombre para la funci√≥n (üìù). Idealmente tiene que ser corto y evocar lo que la funci√≥n hace. En general, debe ser un verbo (p. ej. imputar_valores) mientras que los argumentos son sustantivos (p. ej. data, variable, etc.). Usar un sustantivo para una funci√≥n est√° permitido si la funci√≥n calcula algo muy conocido (p. ej. `mean()`) o si sirve para acceder a partes de un objeto (p. ej. `residuals()`). Tambi√©n se recomienda evitar verbos muy gen√©ricos (p. ej. calcular) y si el nombre tiene varias palabras separarlas con gui√≥n bajo o may√∫sculas, pero ser consistente. Si programas varias funciones que hacen cosas parecidas se recomienda usar el mismo prefijo para todas (p. ej. "str\_" en el paquete {stringr}).

4.  Enumerar los argumentos dentro de `function()` y poner el c√≥digo simplificado dentro de las llaves.

```{r funcion_escribir}

explorar_penguins <- function (var) {
  ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) + 
    geom_point(position = position_jitterdodge(), alpha = 0.3) +     
    geom_boxplot(alpha = 0.5) +     
    scale_color_manual(values = c("turquoise", "goldenrod1")) +     
    theme_light() +     
    ylab(var)
}
```

üìù Utiliza comentarios (#) para explicar el razonamiento detr√°s de tus funciones. Se debe evitar explicar qu√© se est√° haciendo o c√≥mo, ya que el propio c√≥digo ya lo comunica. Tambi√©n se recomienda usar \# para separar apartados (Cmd/Ctrl + Shift + R).

5.  Probar la funci√≥n con entradas diferentes

```{r funcion_pruebas}

explorar_penguins(var = "body_mass_g")  
explorar_penguins(var = "flipper_length_mm")  
explorar_penguins(var = "bill_depth_mm")
```

#### Ejercicio

Genera una funci√≥n para estandarizar (es decir, restar la media y dividir por la desviaci√≥n t√≠pica) las variables num√©ricas de penguins.

### Argumentos

En general hay dos grupos: los que especifican los **datos** y los que especifican **detalles** de la ejecuci√≥n de la funci√≥n. Normalmente los que especifican datos se colocan primero y los de detalle despu√©s. Estos √∫ltimos suelen tener valores por defecto (los m√°s comunes), para cuando no se especifique nada.

<!--# Ver ayuda de quantile -->

üìù Los nombres de los argumentos deben ser cortos y descriptivos. Hay algunos comunes pero poco descriptivos que ya son conocidos para la mayor√≠a de los usuarios y est√° bien aprovecharlos:

`x, y, z`: vectores

`w`: vector de pesos

`df`: data frame

`i, j`: indices numericos, filas y columnas respectivamente

`n`: longitud o n√∫mero de filas

`p`: numero de columnas

`na.rm`: valores faltantes

## Iteraciones con bucles *for*

Los bucles son recomendables para adentrarse en el mundo de las iteraciones porque hacen cada iteraci√≥n muy expl√≠cita para que quede claro lo que est√° pasando.

![Representaci√≥n gr√°fica del funcionamiento de los bucles for donde se ve claramente que se est√° realizando una iteraci√≥n. Ilustraci√≥n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/forloops.png)

Para programar un bucle es necesario definir tres partes diferentes: la salida, la secuencia y el cuerpo.

```{r for}

set.seed(123)  

df_ej <- data.frame(
  a = sample(1:5),
  b = sample(1:5),
  c = sample(1:5) )  

salida <- vector("double", 3)           # 1. salida 

for (i in 1:3) {                        # 2. secuencia   
  salida[[i]] <- first(df_ej[[i]])      # 3. cuerpo 
}  

salida  

# podriamos generalizar el for 

salida <- vector("double", ncol(df_ej))   # 1. salida 

for (i in seq_along(df_ej)) {             # 2. secuencia   
  salida[[i]] <- first(df_ej[[i]])        # 3. cuerpo 
}  

salida  

# tambien podriamos iterar sobre filas 

salida <- vector("double", nrow(df_ej))  

for(i in 1:nrow(df_ej)) {     
  salida[[i]] <- sum(df_ej[i, ]) 
}  

salida
```

1.  Salida: aqu√≠ determinamos el espacio de la salida, es decir, primero tenemos que crear la libreta donde vamos a ir apuntando todos los resultados.

2.  Secuencia: aqu√≠ determinamos sobre lo que queremos iterar. Cada ejecuci√≥n del bucle *for* asignar√° un valor diferente de `seq_along(y)` a `i`.

3.  Cuerpo: aqu√≠ determinamos lo que queremos que haga cada iteraci√≥n. Se ejecuta repetidamente, cada vez con un valor diferente para `i`.

Existe la creencia de que los bucles *for* son lentos, pero la desventaja real de *los bucles for es que son demasiado flexibles* y pueden realizar muchas tareas diferentes. En cambio, cada funcional ({[purrr](https://purrr.tidyverse.org/)}, [`apply`](https://www.r-bloggers.com/2022/03/complete-tutorial-on-using-apply-functions-in-r/)) est√° dise√±ado para una tarea espec√≠fica, por lo que en cuanto lo ves en el c√≥digo, inmediatamente sabes por qu√© se est√° utilizando. Es decir, la principal ventaja es su claridad al hacer que el c√≥digo sea m√°s f√°cil de escribir y de leer.

Los bucles pueden ser m√°s expl√≠citos en cuanto a que se ve claramente la iteraci√≥n, pero se necesita m√°s tiempo para entender qu√© se est√° haciendo. Por el contrario, los funcionales necesitan un paso m√°s de abstracci√≥n. Lo m√°s importante es que soluciones el problema y poco a poco ir escribiendo c√≥digo cada vez m√°s sencillo y elegante.

## Iteraciones con funcionales

![Representaci√≥n gr√°fica del funcionamiento de map() donde el foco est√° en la operaci√≥n realizada. Ilustraci√≥n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/map_frosting.png)

Un funcional es una funci√≥n que toma una funci√≥n como entrada y devuelve un vector u otro tipo de objeto como salida.

Para programar un funcional, primero, solucionamos el problema para un elemento. Despu√©s, generamos una funci√≥n que nos permita envolver la soluci√≥n en una funci√≥n (como lo hicimos en @sec-writefun). Por √∫ltimo, *aplicamos la funci√≥n a todos los elementos que estamos interesados.* Es decir, dividimos los problemas grandes en problemas m√°s peque√±os y resolvemos cada tarea con una o m√°s funciones.

En *tidyverse* se iteran procesos mediante el paquete {purrr}. Comparando los funcionales con los bucles, el foco est√° en la operaci√≥n que se est√° ejecutando, y no en el c√≥digo necesario para iterar sobre cada elemento y guardar la salida.

```{r map_foco}

map(df_ej, first)  

df_ej |>    
  map(first)  

salida <- vector("list", length = 3) 

for (i in 1:3) {   
  salida[[i]] <- first(df_ej[[i]]) 
} 

salida
```

### Nuestro primer funcional: generando listas, `map()`

`map_*()` est√° vectorizado sobre un argumento, p. ej. `(x)`. La funci√≥n operar√° en todos los elementos de `x`, es decir, cada valor si `x` es un vector, cada columna si `x` es un `data.frame`, o cada elemento si `x` es una lista.

Toma un vector y una funci√≥n, llama a la funci√≥n una vez por cada elemento del vector y devuelve los resultados en una lista. `map(1:3, f)` es equivalente a `list(f(1), f(2), f(3))`. Es el equivalente de `lapply()` de R base.

```{r map_ejemplo}

cuadratica <- function(x) {   
  x ^ 2 
}  

map_ouput_list <- map(.x = 1:4, .f = cuadratica)  
lapply_ouput_list <- lapply(X = 1:4, FUN = cuadratica)  

```

![](images/map.png)

#### Ejercicio

Generad un vector, una funci√≥n y aplicadle la funci√≥n a cada uno de los elementos del vector utilizando `map()`.

Los argumentos que var√≠an para cada ejecuci√≥n se ponen antes de la funci√≥n y los argumentos que son los mismos para cada ejecuci√≥n se ponen despu√©s (p. ej. `na.rm = T`).

![](images/map+fix.png)

### Nuestro segundo funcional: generando vectores, `map_*()`

#### Ejercicio

Dedicadle un par de minutos a entender lo que hacen las siguientes funciones:

```{r map_vectores}

map_lgl(penguins, is.numeric) 
penguins_num <- penguins[ , map_lgl(penguins, is.numeric)]  

map_dbl(penguins_num, median, na.rm = T) 

map_chr(penguins, class) 

map_int(penguins, \(x) length(unique(x))) 

1:4 |>
  map_vec(\(x) as.Date(ISOdate(x + 2024, 12, 03)))
```

### Enlaces de inter√©s sobre programaci√≥n funcional

-   [Introducci√≥n a la programaci√≥n funcional (DatSciR)](https://github.com/DatSciR/intro_prog_fun/tree/main/lleida)

-   [R for data Science (functions)](https://r4ds.had.co.nz/functions.html)

-   [Advanced R (functions)](https://adv-r.hadley.nz/functions.html)

-   [R for data Science (iteration)](https://r4ds.had.co.nz/iteration.html)

-   [Advanced R (functionals)](https://adv-r.hadley.nz/functionals.html)

-   [purrr 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/)

-   [Learn to purrr (Rebecca Barter)](https://www.rebeccabarter.com/blog/2019-08-19_purrr)

------------------------------------------------------------------------

<details>

<summary>Session Info</summary>

```{r session_info}
Sys.time()
sessionInfo()
```

</details>
